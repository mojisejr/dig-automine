Directory structure:
└── digdragonnft-digdragonnft-front/
    ├── README.md
    ├── next.config.mjs
    ├── package.json
    ├── postcss.config.cjs
    ├── prettier.config.mjs
    ├── sanity.cli.ts
    ├── sanity.config.ts
    ├── tailwind.config.ts
    ├── tsconfig.json
    ├── .env.example
    ├── .eslintrc.backup.cjs
    ├── .gitconfig
    ├── prisma/
    │   └── schema.prisma
    ├── sanity/
    │   ├── env.ts
    │   ├── schema.ts
    │   ├── lib/
    │   │   ├── client.ts
    │   │   ├── image.ts
    │   │   └── nft/
    │   │       └── index.ts
    │   └── schema/
    │       ├── JIbJib.ts
    │       ├── Mine.ts
    │       ├── NFTCollection.ts
    │       ├── Privilege.ts
    │       └── Reward.ts
    └── src/
        ├── env.mjs
        ├── blockchain/
        │   ├── constants/
        │   │   ├── bitkub.ts
        │   │   └── jbc.ts
        │   ├── ERC20/
        │   │   └── abi.ts
        │   ├── JBC/
        │   │   ├── Distributor/
        │   │   │   ├── abi.ts
        │   │   │   └── claim.ts
        │   │   └── DistributorWhitelist/
        │   │       ├── abi.ts
        │   │       └── claim.ts
        │   ├── Mine/
        │   │   ├── abi.ts
        │   │   ├── abi2.ts
        │   │   ├── abi3.ts
        │   │   ├── stake.ts
        │   │   └── unstake.ts
        │   └── NFT/
        │       ├── abi.ts
        │       ├── mint.ts
        │       ├── revoke.ts
        │       └── setApprovalForAll.ts
        ├── components/
        │   ├── Home/
        │   │   ├── BoxLeft.tsx
        │   │   ├── BoxRight.tsx
        │   │   └── BoxRightV2.tsx
        │   ├── Mine/
        │   │   ├── CardElement.tsx
        │   │   ├── Table.tsx
        │   │   └── TableElement.tsx
        │   ├── Privilege/
        │   │   ├── Card.tsx
        │   │   └── List.tsx
        │   ├── Shared/
        │   │   ├── LoadingScreen.tsx
        │   │   ├── PleaseConnectWallet.tsx
        │   │   ├── Button/
        │   │   │   └── FloatingButton.tsx
        │   │   ├── Card/
        │   │   │   ├── StatCard1.tsx
        │   │   │   ├── StatCard2.tsx
        │   │   │   ├── StatCard3.tsx
        │   │   │   └── StatCardOutline.tsx
        │   │   ├── Inidcators/
        │   │   │   └── Loading.tsx
        │   │   ├── Layout/
        │   │   │   ├── BaseLayoutV2.tsx
        │   │   │   ├── GridCell.tsx
        │   │   │   ├── GridLayout.tsx
        │   │   │   └── GridSpacer.tsx
        │   │   ├── Nav/
        │   │   │   └── NavBarV2.tsx
        │   │   └── Typepography/
        │   │       ├── Address.tsx
        │   │       ├── SecondHeader.tsx
        │   │       ├── RollingNumber/
        │   │       │   └── index.tsx
        │   │       └── TypingText/
        │   │           ├── Cursor.tsx
        │   │           └── Text.tsx
        │   └── Wallet/
        │       └── Card/
        │           └── NftCard.tsx
        ├── interfaces/
        │   ├── blockchain/
        │   │   ├── Mine/
        │   │   │   └── MineData.ts
        │   │   └── NFT/
        │   │       └── DigdragonMetadata.ts
        │   ├── components/
        │   │   └── Shared/
        │   │       ├── BaseLayoutProps.ts
        │   │       ├── Container/
        │   │       │   └── BaseContainerProps.ts
        │   │       └── Navbar/
        │   │           └── MenuItemProps.ts
        │   └── Wallet/
        │       ├── MyNFTProps.ts
        │       ├── MyNFTRarity.ts
        │       ├── MyNFTStatProps.ts
        │       └── MyNFTStatusProp.ts
        ├── pages/
        │   ├── _app.tsx
        │   ├── index.tsx
        │   ├── api/
        │   │   └── trpc/
        │   │       └── [trpc].ts
        │   ├── dig-space/
        │   │   └── [[...index]].tsx
        │   ├── mine/
        │   │   └── index.tsx
        │   ├── privilege/
        │   │   ├── index.tsx
        │   │   └── jibjib.tsx
        │   └── wallet/
        │       ├── dig-x-moon.tsx
        │       ├── index.tsx
        │       └── v2.tsx
        ├── server/
        │   ├── db.ts
        │   └── api/
        │       ├── root.ts
        │       ├── trpc.ts
        │       ├── routers/
        │       │   ├── blockchain.ts
        │       │   ├── digxmoon.ts
        │       │   ├── jib-distributor-whitelist.ts
        │       │   ├── jib-distributor.ts
        │       │   ├── mine.ts
        │       │   ├── nft.ts
        │       │   └── reward.ts
        │       ├── services/
        │       │   ├── blockchain.service.ts
        │       │   ├── digxmoon.service.ts
        │       │   ├── mine.service.ts
        │       │   ├── nft.service.ts
        │       │   ├── reward.service.ts
        │       │   ├── via-btc.service.ts
        │       │   ├── viem.service.ts
        │       │   └── v2/
        │       │       ├── mine-v2.service.ts
        │       │       └── jbc/
        │       │           ├── jbc.distributor-whitelist.service.ts
        │       │           └── jbc.distributor.service.ts
        │       └── utils/
        │           ├── contractAPR.ts
        │           └── RewardCalculation.ts
        ├── styles/
        │   └── globals.css
        ├── types/
        │   └── Address.ts
        └── utils/
            └── api.ts

================================================
FILE: README.md
================================================
# Create T3 App : Digdragon NFT



================================================
FILE: next.config.mjs
================================================
/**
 * Run `build` or `dev` with `SKIP_ENV_VALIDATION` to skip env validation. This is especially useful
 * for Docker builds.
 */
await import("./src/env.mjs");

/** @type {import("next").NextConfig} */
const config = {
  reactStrictMode: true,

  /**
   * If you are using `appDir` then you must comment the below `i18n` config out.
   *
   * @see https://github.com/vercel/next.js/issues/41980
   */
  i18n: {
    locales: ["en"],
    defaultLocale: "en",
  },
};

export default config;



================================================
FILE: package.json
================================================
{
  "name": "digdragonnft-front",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "build": "next build",
    "db:push": "prisma db push",
    "dev": "next dev",
    "postinstall": "prisma generate",
    "lint": "next lint",
    "start": "next start"
  },
  "dependencies": {
    "@prisma/client": "^5.1.1",
    "@rainbow-me/rainbowkit": "^1.1.2",
    "@sanity/image-url": "^1.0.2",
    "@sanity/vision": "^3.18.0",
    "@t3-oss/env-nextjs": "^0.7.0",
    "@tanstack/react-query": "^4.32.6",
    "@trpc/client": "^10.37.1",
    "@trpc/next": "^10.37.1",
    "@trpc/react-query": "^10.37.1",
    "@trpc/server": "^10.37.1",
    "axios": "^1.5.1",
    "cheerio": "^1.0.0-rc.12",
    "dayjs": "^1.11.10",
    "framer-motion": "^10.16.4",
    "next": "^13.5.4",
    "next-sanity": "^5.5.8",
    "puppeteer": "^21.7.0",
    "react": "18.2.0",
    "react-countup": "^6.5.0",
    "react-dom": "18.2.0",
    "react-icons": "^4.11.0",
    "react-toastify": "^9.1.3",
    "sanity": "^3.18.0",
    "styled-components": "^6.1.17",
    "superjson": "^1.13.1",
    "viem": "^1.16.5",
    "wagmi": "^1.4.3",
    "web3-token": "^1.0.6",
    "zod": "^3.22.4"
  },
  "devDependencies": {
    "@types/eslint": "^8.44.2",
    "@types/node": "^18.16.0",
    "@types/react": "^18.2.20",
    "@types/react-dom": "^18.2.7",
    "@typescript-eslint/eslint-plugin": "^6.3.0",
    "@typescript-eslint/parser": "^6.3.0",
    "autoprefixer": "^10.4.14",
    "daisyui": "^3.9.2",
    "eslint": "^8.47.0",
    "eslint-config-next": "^13.5.4",
    "postcss": "^8.4.27",
    "prettier": "^3.0.0",
    "prettier-plugin-tailwindcss": "^0.5.1",
    "prisma": "^5.1.1",
    "tailwindcss": "^3.3.3",
    "typescript": "^5.1.6"
  },
  "ct3aMetadata": {
    "initVersion": "7.21.0"
  },
  "packageManager": "npm@9.8.1"
}



================================================
FILE: postcss.config.cjs
================================================
const config = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
};

module.exports = config;



================================================
FILE: prettier.config.mjs
================================================
/** @type {import('prettier').Config & import('prettier-plugin-tailwindcss').options} */
const config = {
  plugins: ["prettier-plugin-tailwindcss"],
};

export default config;



================================================
FILE: sanity.cli.ts
================================================
/**
* This configuration file lets you run `$ sanity [command]` in this folder
* Go to https://www.sanity.io/docs/cli to learn more.
**/
import { defineCliConfig } from 'sanity/cli'

const projectId = process.env.NEXT_PUBLIC_SANITY_PROJECT_ID
const dataset = process.env.NEXT_PUBLIC_SANITY_DATASET

export default defineCliConfig({ api: { projectId, dataset } })



================================================
FILE: sanity.config.ts
================================================
/**
 * This configuration is used to for the Sanity Studio that’s mounted on the `/pages/dig-space/[[...index]].tsx` route
 */

import {visionTool} from '@sanity/vision'
import {defineConfig} from 'sanity'
import {deskTool} from 'sanity/desk'

// Go to https://www.sanity.io/docs/api-versioning to learn how API versioning works
import {apiVersion, dataset, projectId} from './sanity/env'
import {schema} from './sanity/schema'

export default defineConfig({
  basePath: '/dig-space',
  projectId,
  dataset,
  // Add and edit the content schema in the './sanity/schema' folder
  schema,
  plugins: [
    deskTool(),
    // Vision is a tool that lets you query your content with GROQ in the studio
    // https://www.sanity.io/docs/the-vision-plugin
    visionTool({defaultApiVersion: apiVersion}),
  ],
})



================================================
FILE: tailwind.config.ts
================================================
import { type Config } from "tailwindcss";

export default {
  content: ["./src/**/*.{js,ts,jsx,tsx}"],
  daisyui: {
    themes: [
      {
        mytheme: {
          primary: "#111827",

          secondary: "#D9D9D9",

          accent: "#aa0507",

          neutral: "#232323",

          "base-100": "#F3F4F6",

          info: "#3b97e8",

          success: "#5EAF2C",

          warning: "#efc52e",

          error: "#e83026",
        },
      },
    ],
  },
  plugins: [require("daisyui")],
} satisfies Config;



================================================
FILE: tsconfig.json
================================================
{
  "compilerOptions": {
    "target": "es2017",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "checkJs": true,
    "skipLibCheck": true,
    "strict": true,
    "forceConsistentCasingInFileNames": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "node",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "noUncheckedIndexedAccess": true,
    "baseUrl": ".",
    "paths": {
      "~/*": ["./src/*"]
    }
  },
  "include": [
    ".eslintrc.cjs",
    "next-env.d.ts",
    "**/*.ts",
    "**/*.tsx",
    "**/*.cjs",
    "**/*.mjs"
  ],
  "exclude": ["node_modules"]
}



================================================
FILE: .env.example
================================================
# Since the ".env" file is gitignored, you can use the ".env.example" file to
# build a new ".env" file when you clone the repo. Keep this file up-to-date
# when you add new variables to `.env`.

# This file will be committed to version control, so make sure not to have any
# secrets in it. If you are cloning this repo, create a copy of this file named
# ".env" and populate it with your secrets.

# When adding additional environment variables, the schema in "/src/env.mjs"
# should be updated accordingly.

# Prisma
# https://www.prisma.io/docs/reference/database-reference/connection-urls#env
DATABASE_URL="file:./db.sqlite"



================================================
FILE: .eslintrc.backup.cjs
================================================
/** @type {import("eslint").Linter.Config} */
const config = {
  parser: "@typescript-eslint/parser",
  parserOptions: {
    project: true,
  },
  plugins: ["@typescript-eslint"],
  extends: [
    "next/core-web-vitals",
    "plugin:@typescript-eslint/recommended-type-checked",
    "plugin:@typescript-eslint/stylistic-type-checked",
  ],
  rules: {
    // These opinionated rules are enabled in stylistic-type-checked above.
    // Feel free to reconfigure them to your own preference.
    "@typescript-eslint/array-type": "off",
    "@typescript-eslint/consistent-type-definitions": "off",

    "@typescript-eslint/consistent-type-imports": [
      "warn",
      {
        prefer: "type-imports",
        fixStyle: "inline-type-imports",
      },
    ],
    "@typescript-eslint/no-unused-vars": ["warn", { argsIgnorePattern: "^_" }],
  },
};

module.exports = config;



================================================
FILE: .gitconfig
================================================
[user]
	name=digdragonnft-admin
	email=digdragonnft@gmail.com



================================================
FILE: prisma/schema.prisma
================================================
// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
    provider = "prisma-client-js"
}

datasource db {
    provider = "sqlite"
    url      = env("DATABASE_URL")
}

model Example {
    id        Int      @id @default(autoincrement())
    name      String
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    @@index([name])
}



================================================
FILE: sanity/env.ts
================================================
export const apiVersion =
  process.env.NEXT_PUBLIC_SANITY_API_VERSION || "2023-10-15";

export const dataset = assertValue(
  process.env.NEXT_PUBLIC_SANITY_DATASET,
  "Missing environment variable: NEXT_PUBLIC_SANITY_DATASET",
);

export const projectId = assertValue(
  process.env.NEXT_PUBLIC_SANITY_PROJECT_ID,
  "Missing environment variable: NEXT_PUBLIC_SANITY_PROJECT_ID",
);

export const useCdn = false;
export const token = process.env.NEXT_PUBLIC_SANITY_API_KEY;

function assertValue<T>(v: T | undefined, errorMessage: string): T {
  if (v === undefined) {
    throw new Error(errorMessage);
  }

  return v;
}



================================================
FILE: sanity/schema.ts
================================================
import { type SchemaTypeDefinition } from "sanity";
import { MineType } from "./schema/Mine";
import { nftCollectionType } from "./schema/NFTCollection";
import { rewardType } from "./schema/Reward";
import { BlogType, privilegeType } from "./schema/Privilege";
import { jibjibRewardType } from "./schema/JIbJib";

export const schema: { types: SchemaTypeDefinition[] } = {
  types: [
    MineType,
    nftCollectionType,
    rewardType,
    privilegeType,
    BlogType,
    jibjibRewardType,
  ],
};



================================================
FILE: sanity/lib/client.ts
================================================
import { createClient } from "next-sanity";

import { apiVersion, dataset, projectId, useCdn, token } from "../env";

export const client = createClient({
  apiVersion,
  dataset,
  projectId,
  useCdn,
  token,
});



================================================
FILE: sanity/lib/image.ts
================================================
import createImageUrlBuilder from '@sanity/image-url'
import type { Image } from 'sanity'

import { dataset, projectId } from '../env'

const imageBuilder = createImageUrlBuilder({
  projectId: projectId || '',
  dataset: dataset || '',
})

export const urlForImage = (source: Image) => {
  return imageBuilder?.image(source).auto('format').fit('max')
}



================================================
FILE: sanity/lib/nft/index.ts
================================================
import { groq } from "next-sanity";
import { client } from "../client";

export const getCollections = async () => {
  try {
    const query = groq`*[_type == "collection"]`;
    const collections = await client.fetch(query);
    return collections as any[];
  } catch (error) {
    console.log(error);
    return [];
  }
};



================================================
FILE: sanity/schema/JIbJib.ts
================================================
import { defineType, defineField } from "sanity";

export const jibjibRewardType = defineType({
  title: "JIBJIBClaimer",
  name: "jibjib",
  type: "document",
  fields: [
    defineField({
      title: "Wallet",
      name: "wallet",
      type: "string",
    }),
    defineField({
      title: "Claiming TokenIds",
      name: "tokenIds",
      type: "string",
    }),
    defineField({
      title: "isApproved",
      name: "approved",
      type: "boolean",
      initialValue: false,
    }),
  ],
});



================================================
FILE: sanity/schema/Mine.ts
================================================
import { defineField, defineType } from "sanity";

export const MineType = defineType({
  name: "mine",
  type: "document",
  title: "Mine Data",
  fields: [
    defineField({
      name: "name",
      title: "Mine Pairs",
      type: "string",
    }),

    defineField({
      name: "address",
      title: "Mine Contract Address",
      type: "string",
    }),

    defineField({
      name: "image",
      title: "Thumbnail Image or Logo Image or Avatar Image",
      type: "image",
    }),

    defineField({
      name: "description",
      title: "Description",
      type: "string",
    }),

    defineField({
      name: "specialFunctions",
      title: "Sepecial Functons List",
      type: "array",
      of: [{ type: "string" }],
    }),

    defineField({
      name: "nfts",
      title: "Available NFT of this mine",
      type: "array",
      of: [{ type: "reference", to: [{ type: "collection" }] }],
    }),

    defineField({
      name: "rewards",
      title: "Rewards Tokens",
      type: "array",
      of: [{ type: "reference", to: [{ type: "reward" }] }],
    }),

    defineField({
      name: "isActive",
      title: "Is Mining Open ?",
      type: "boolean",
      validation: (Rule) => Rule.required(),
    }),
  ],
});



================================================
FILE: sanity/schema/NFTCollection.ts
================================================
import { defineField, defineType } from "sanity";

export const nftCollectionType = defineType({
  name: "collection",
  title: "NFT Collection",
  type: "document",
  fields: [
    defineField({
      name: "collectionName",
      title: "Collection Name",
      type: "string",
    }),

    defineField({
      name: "button",
      title: "Button Name",
      type: "string",
    }),

    defineField({
      name: "address",
      title: "NFT Contract Address",
      type: "string",
    }),

    defineField({
      name: "description",
      title: "Description",
      type: "text",
    }),

    defineField({
      name: "image",
      title: "Thumnail Image or Logo Image or Avatar Image",
      type: "image",
    }),

    defineField({
      name: "mine",
      title: "Available Mine",
      type: "array",
      of: [{ type: "reference", to: [{ type: "mine" }] }],
    }),

    defineField({
      name: "slug",
      title: "Slug",
      type: "slug",
      options: {
        source: "collectionName",
      },
    }),

    defineField({
      name: "active",
      title: "isActive",
      type: "boolean",
      initialValue: true,
    }),
  ],
});



================================================
FILE: sanity/schema/Privilege.ts
================================================
import { defineField, defineType, defineArrayMember } from "sanity";

export const privilegeType = defineType({
  name: "privilege",
  title: "Privilege",
  type: "document",
  fields: [
    defineField({
      name: "title",
      title: "Privilege Title",
      type: "string",
    }),

    defineField({
      name: "description",
      title: "Description",
      type: "string",
    }),

    defineField({
      name: "banner",
      title: "Banner Image",
      type: "image",
    }),

    defineField({
      name: "body",
      title: "Body",
      type: "blockContent",
    }),
  ],
});

/**
 * This is the schema definition for the rich text fields used for
 * for this blog studio. When you import it in schemas.js it can be
 * reused in other parts of the studio with:
 *  {
 *    name: 'someName',
 *    title: 'Some title',
 *    type: 'blockContent'
 *  }
 */
export const BlogType = defineType({
  title: "Block Content",
  name: "blockContent",
  type: "array",
  of: [
    defineArrayMember({
      title: "Block",
      type: "block",
      // Styles let you set what your user can mark up blocks with. These
      // correspond with HTML tags, but you can set any title or value
      // you want and decide how you want to deal with it where you want to
      // use your content.
      styles: [
        { title: "Normal", value: "normal" },
        { title: "H1", value: "h1" },
        { title: "H2", value: "h2" },
        { title: "H3", value: "h3" },
        { title: "H4", value: "h4" },
        { title: "Quote", value: "blockquote" },
      ],
      lists: [{ title: "Bullet", value: "bullet" }],
      // Marks let you mark up inline text in the block editor.
      marks: {
        // Decorators usually describe a single property – e.g. a typographic
        // preference or highlighting by editors.
        decorators: [
          { title: "Strong", value: "strong" },
          { title: "Emphasis", value: "em" },
        ],
        // Annotations can be any object structure – e.g. a link or a footnote.
        annotations: [
          {
            title: "URL",
            name: "link",
            type: "object",
            fields: [
              {
                title: "URL",
                name: "href",
                type: "url",
              },
            ],
          },
        ],
      },
    }),
    // You can add additional types here. Note that you can't use
    // primitive types such as 'string' and 'number' in the same array
    // as a block type.
    defineArrayMember({
      type: "image",
      options: { hotspot: true },
    }),
  ],
});



================================================
FILE: sanity/schema/Reward.ts
================================================
import { defineField, defineType } from "sanity";

export const rewardType = defineType({
  name: "reward",
  title: "Reward Token",
  type: "document",
  fields: [
    defineField({
      name: "name",
      title: "Reward Name",
      type: "string",
    }),

    defineField({
      name: "address",
      title: "Reward Address",
      type: "string",
    }),

    defineField({
      name: "description",
      title: "Description",
      type: "string",
    }),

    defineField({
      name: "image",
      title: "Thumnail Image, Logo Image or Avatar Image",
      type: "image",
    }),
  ],
});



================================================
FILE: src/env.mjs
================================================
import { createEnv } from "@t3-oss/env-nextjs";
import { z } from "zod";

export const env = createEnv({
  /**
   * Specify your server-side environment variables schema here. This way you can ensure the app
   * isn't built with invalid env vars.
   */
  server: {
    DATABASE_URL: z
      .string()
      .url()
      .refine(
        (str) => !str.includes("YOUR_MYSQL_URL_HERE"),
        "You forgot to change the default URL"
      ),
    NODE_ENV: z
      .enum(["development", "test", "production"])
      .default("development"),
  },

  /**
   * Specify your client-side environment variables schema here. This way you can ensure the app
   * isn't built with invalid env vars. To expose them to the client, prefix them with
   * `NEXT_PUBLIC_`.
   */
  client: {
    // NEXT_PUBLIC_CLIENTVAR: z.string(),
  },

  /**
   * You can't destruct `process.env` as a regular object in the Next.js edge runtimes (e.g.
   * middlewares) or client-side so we need to destruct manually.
   */
  runtimeEnv: {
    DATABASE_URL: process.env.DATABASE_URL,
    NODE_ENV: process.env.NODE_ENV,
    // NEXT_PUBLIC_CLIENTVAR: process.env.NEXT_PUBLIC_CLIENTVAR,
  },
  /**
   * Run `build` or `dev` with `SKIP_ENV_VALIDATION` to skip env validation. This is especially
   * useful for Docker builds.
   */
  skipValidation: !!process.env.SKIP_ENV_VALIDATION,
  /**
   * Makes it so that empty strings are treated as undefined.
   * `SOME_VAR: z.string()` and `SOME_VAR=''` will throw an error.
   */
  emptyStringAsUndefined: true,
});



================================================
FILE: src/blockchain/constants/bitkub.ts
================================================
import { Chain } from "wagmi";

export const bitkub = {
  id: 96,
  name: "Bitkub",
  network: "bitkubchain",
  nativeCurrency: {
    decimals: 18,
    name: "KUB",
    symbol: "KUB",
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.bitkubchain.io"],
    },
    public: {
      http: ["https://rpc.bitkubchain.io"],
    },
  },
  blockExplorers: {
    default: { name: "BKCScan", url: "https://bkcscan.com" },
  },
  testnet: false,
} as const satisfies Chain;

export const bitkub_testnet = {
  id: 25_925,
  name: "bitkub_testnet",
  network: "bitkub_testnet",
  nativeCurrency: {
    decimals: 18,
    name: "KUB",
    symbol: "KUB",
  },
  rpcUrls: {
    default: { http: ["https://rpc-testnet.bitkubchain.io"] },
    public: {
      http: ["https://rpc.bitkubchain.io"],
    },
  },
  blockExplorers: {
    default: { name: "SnowTrace", url: "https://testnet.bkcscan.com" },
  },
  testnet: true,
} as const satisfies Chain;



================================================
FILE: src/blockchain/constants/jbc.ts
================================================
import { Chain } from "wagmi";

export const jbc = {
  id: 8899,
  name: "JBC Chain",
  network: "JBC L1 Network",
  nativeCurrency: {
    decimals: 18,
    name: "JBC",
    symbol: "JBC",
  },
  rpcUrls: {
    default: {
      http: ["https://rpc-l1.jibchain.net/"],
    },
    public: {
      http: ["https://rpc-l1.jibchain.net/"],
    },
  },
  blockExplorers: {
    default: {
      name: "JBC Block Explorer",
      url: "https://exp-l1.jibchain.net/",
    },
  },
  testnet: false,
} as const satisfies Chain;



================================================
FILE: src/blockchain/ERC20/abi.ts
================================================
export const abi = [
  {
    type: "constructor",
    stateMutability: "nonpayable",
    inputs: [
      { type: "address", name: "admin", internalType: "address" },
      { type: "address", name: "committee", internalType: "address" },
      {
        type: "address",
        name: "kyc",
        internalType: "contract IKYCBitkubChain",
      },
      { type: "uint256", name: "acceptedKycLevel", internalType: "uint256" },
    ],
  },
  {
    type: "event",
    name: "AddBlacklist",
    inputs: [
      {
        type: "address",
        name: "account",
        internalType: "address",
        indexed: true,
      },
      {
        type: "address",
        name: "caller",
        internalType: "address",
        indexed: true,
      },
    ],
    anonymous: false,
  },
  {
    type: "event",
    name: "Approval",
    inputs: [
      {
        type: "address",
        name: "owner",
        internalType: "address",
        indexed: true,
      },
      {
        type: "address",
        name: "spender",
        internalType: "address",
        indexed: true,
      },
      {
        type: "uint256",
        name: "value",
        internalType: "uint256",
        indexed: false,
      },
    ],
    anonymous: false,
  },
  {
    type: "event",
    name: "Paused",
    inputs: [
      {
        type: "address",
        name: "account",
        internalType: "address",
        indexed: false,
      },
    ],
    anonymous: false,
  },
  {
    type: "event",
    name: "RevokeBlacklist",
    inputs: [
      {
        type: "address",
        name: "account",
        internalType: "address",
        indexed: true,
      },
      {
        type: "address",
        name: "caller",
        internalType: "address",
        indexed: true,
      },
    ],
    anonymous: false,
  },
  {
    type: "event",
    name: "SetAdmin",
    inputs: [
      {
        type: "address",
        name: "oldAdmin",
        internalType: "address",
        indexed: true,
      },
      {
        type: "address",
        name: "newAdmin",
        internalType: "address",
        indexed: true,
      },
      {
        type: "address",
        name: "caller",
        internalType: "address",
        indexed: true,
      },
    ],
    anonymous: false,
  },
  {
    type: "event",
    name: "SetCommittee",
    inputs: [
      {
        type: "address",
        name: "oldCommittee",
        internalType: "address",
        indexed: true,
      },
      {
        type: "address",
        name: "newCommittee",
        internalType: "address",
        indexed: true,
      },
      {
        type: "address",
        name: "caller",
        internalType: "address",
        indexed: true,
      },
    ],
    anonymous: false,
  },
  {
    type: "event",
    name: "Transfer",
    inputs: [
      { type: "address", name: "from", internalType: "address", indexed: true },
      { type: "address", name: "to", internalType: "address", indexed: true },
      {
        type: "uint256",
        name: "value",
        internalType: "uint256",
        indexed: false,
      },
    ],
    anonymous: false,
  },
  {
    type: "event",
    name: "Unpaused",
    inputs: [
      {
        type: "address",
        name: "account",
        internalType: "address",
        indexed: false,
      },
    ],
    anonymous: false,
  },
  {
    type: "function",
    stateMutability: "view",
    outputs: [{ type: "uint256", name: "", internalType: "uint256" }],
    name: "acceptedKycLevel",
    inputs: [],
  },
  {
    type: "function",
    stateMutability: "nonpayable",
    outputs: [],
    name: "activateOnlyKycAddress",
    inputs: [],
  },
  {
    type: "function",
    stateMutability: "nonpayable",
    outputs: [],
    name: "addBlacklist",
    inputs: [{ type: "address", name: "account", internalType: "address" }],
  },
  {
    type: "function",
    stateMutability: "view",
    outputs: [{ type: "address", name: "", internalType: "address" }],
    name: "admin",
    inputs: [],
  },
  {
    type: "function",
    stateMutability: "nonpayable",
    outputs: [{ type: "bool", name: "", internalType: "bool" }],
    name: "adminTransfer",
    inputs: [
      { type: "address", name: "sender", internalType: "address" },
      { type: "address", name: "recipient", internalType: "address" },
      { type: "uint256", name: "amount", internalType: "uint256" },
    ],
  },
  {
    type: "function",
    stateMutability: "view",
    outputs: [{ type: "uint256", name: "", internalType: "uint256" }],
    name: "allowances",
    inputs: [
      { type: "address", name: "", internalType: "address" },
      { type: "address", name: "", internalType: "address" },
    ],
  },
  {
    type: "function",
    stateMutability: "nonpayable",
    outputs: [{ type: "bool", name: "", internalType: "bool" }],
    name: "approve",
    inputs: [
      { type: "address", name: "spender", internalType: "address" },
      { type: "uint256", name: "amount", internalType: "uint256" },
    ],
  },
  {
    type: "function",
    stateMutability: "view",
    outputs: [{ type: "uint256", name: "", internalType: "uint256" }],
    name: "balanceOf",
    inputs: [{ type: "address", name: "account", internalType: "address" }],
  },
  {
    type: "function",
    stateMutability: "view",
    outputs: [{ type: "bool", name: "", internalType: "bool" }],
    name: "blacklist",
    inputs: [{ type: "address", name: "", internalType: "address" }],
  },
  {
    type: "function",
    stateMutability: "nonpayable",
    outputs: [{ type: "bool", name: "", internalType: "bool" }],
    name: "burn",
    inputs: [
      { type: "address", name: "account", internalType: "address" },
      { type: "uint256", name: "amount", internalType: "uint256" },
    ],
  },
  {
    type: "function",
    stateMutability: "view",
    outputs: [{ type: "address", name: "", internalType: "address" }],
    name: "committee",
    inputs: [],
  },
  {
    type: "function",
    stateMutability: "view",
    outputs: [{ type: "uint8", name: "", internalType: "uint8" }],
    name: "decimals",
    inputs: [],
  },
  {
    type: "function",
    stateMutability: "nonpayable",
    outputs: [{ type: "bool", name: "", internalType: "bool" }],
    name: "decreaseAllowance",
    inputs: [
      { type: "address", name: "spender", internalType: "address" },
      { type: "uint256", name: "subtractedValue", internalType: "uint256" },
    ],
  },
  {
    type: "function",
    stateMutability: "nonpayable",
    outputs: [{ type: "bool", name: "", internalType: "bool" }],
    name: "externalTransfer",
    inputs: [
      { type: "address", name: "sender", internalType: "address" },
      { type: "address", name: "recipient", internalType: "address" },
      { type: "uint256", name: "amount", internalType: "uint256" },
    ],
  },
  {
    type: "function",
    stateMutability: "nonpayable",
    outputs: [{ type: "bool", name: "", internalType: "bool" }],
    name: "increaseAllowance",
    inputs: [
      { type: "address", name: "spender", internalType: "address" },
      { type: "uint256", name: "addedValue", internalType: "uint256" },
    ],
  },
  {
    type: "function",
    stateMutability: "nonpayable",
    outputs: [{ type: "bool", name: "", internalType: "bool" }],
    name: "internalTransfer",
    inputs: [
      { type: "address", name: "sender", internalType: "address" },
      { type: "address", name: "recipient", internalType: "address" },
      { type: "uint256", name: "amount", internalType: "uint256" },
    ],
  },
  {
    type: "function",
    stateMutability: "view",
    outputs: [{ type: "bool", name: "", internalType: "bool" }],
    name: "isActivatedOnlyKycAddress",
    inputs: [],
  },
  {
    type: "function",
    stateMutability: "view",
    outputs: [
      { type: "address", name: "", internalType: "contract IKYCBitkubChain" },
    ],
    name: "kyc",
    inputs: [],
  },
  {
    type: "function",
    stateMutability: "nonpayable",
    outputs: [{ type: "bool", name: "", internalType: "bool" }],
    name: "mint",
    inputs: [
      { type: "address", name: "account", internalType: "address" },
      { type: "uint256", name: "amount", internalType: "uint256" },
    ],
  },
  {
    type: "function",
    stateMutability: "view",
    outputs: [{ type: "string", name: "", internalType: "string" }],
    name: "name",
    inputs: [],
  },
  {
    type: "function",
    stateMutability: "nonpayable",
    outputs: [],
    name: "pause",
    inputs: [],
  },
  {
    type: "function",
    stateMutability: "view",
    outputs: [{ type: "bool", name: "", internalType: "bool" }],
    name: "paused",
    inputs: [],
  },
  {
    type: "function",
    stateMutability: "nonpayable",
    outputs: [],
    name: "revokeBlacklist",
    inputs: [{ type: "address", name: "account", internalType: "address" }],
  },
  {
    type: "function",
    stateMutability: "nonpayable",
    outputs: [],
    name: "setAcceptedKycLevel",
    inputs: [{ type: "uint256", name: "_kycLevel", internalType: "uint256" }],
  },
  {
    type: "function",
    stateMutability: "nonpayable",
    outputs: [],
    name: "setAdmin",
    inputs: [{ type: "address", name: "_admin", internalType: "address" }],
  },
  {
    type: "function",
    stateMutability: "nonpayable",
    outputs: [],
    name: "setCommittee",
    inputs: [{ type: "address", name: "_committee", internalType: "address" }],
  },
  {
    type: "function",
    stateMutability: "nonpayable",
    outputs: [],
    name: "setKYC",
    inputs: [
      {
        type: "address",
        name: "_kyc",
        internalType: "contract IKYCBitkubChain",
      },
    ],
  },
  {
    type: "function",
    stateMutability: "view",
    outputs: [{ type: "string", name: "", internalType: "string" }],
    name: "symbol",
    inputs: [],
  },
  {
    type: "function",
    stateMutability: "view",
    outputs: [{ type: "uint256", name: "", internalType: "uint256" }],
    name: "totalSupply",
    inputs: [],
  },
  {
    type: "function",
    stateMutability: "nonpayable",
    outputs: [{ type: "bool", name: "", internalType: "bool" }],
    name: "transfer",
    inputs: [
      { type: "address", name: "recipient", internalType: "address" },
      { type: "uint256", name: "amount", internalType: "uint256" },
    ],
  },
  {
    type: "function",
    stateMutability: "nonpayable",
    outputs: [{ type: "bool", name: "", internalType: "bool" }],
    name: "transferFrom",
    inputs: [
      { type: "address", name: "sender", internalType: "address" },
      { type: "address", name: "recipient", internalType: "address" },
      { type: "uint256", name: "amount", internalType: "uint256" },
    ],
  },
  {
    type: "function",
    stateMutability: "nonpayable",
    outputs: [],
    name: "unpause",
    inputs: [],
  },
];

// export const address = "0x584D164cD421cf26C70Fa9926F658803F362C355";
export const address = "0x726613C4494C60B7dCdeA5BE2846180C1DAfBE8B";
export const jibjibAddress = "0xebe937eE67E3219D176965CC08110A258f925e01";



================================================
FILE: src/blockchain/JBC/Distributor/abi.ts
================================================
export const abi = [
  {
    inputs: [
      {
        internalType: "address",
        name: "_rewardToken",
        type: "address",
      },
      {
        internalType: "address",
        name: "_feeCollector",
        type: "address",
      },
    ],
    stateMutability: "nonpayable",
    type: "constructor",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "user",
        type: "address",
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amount",
        type: "uint256",
      },
    ],
    name: "Claimed",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "previousOwner",
        type: "address",
      },
      {
        indexed: true,
        internalType: "address",
        name: "newOwner",
        type: "address",
      },
    ],
    name: "OwnershipTransferred",
    type: "event",
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_amount",
        type: "uint256",
      },
    ],
    name: "calculateFee",
    outputs: [
      {
        internalType: "uint256",
        name: "feeRate",
        type: "uint256",
      },
      {
        internalType: "uint256",
        name: "payout",
        type: "uint256",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [],
    name: "claim",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [],
    name: "getBalance",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_user",
        type: "address",
      },
    ],
    name: "getClaimableOf",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_user",
        type: "address",
      },
    ],
    name: "isClaimable",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [],
    name: "owner",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [],
    name: "paused",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [],
    name: "renounceOwnership",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_user",
        type: "address",
      },
    ],
    name: "resetReward",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [],
    name: "rewardToken",
    outputs: [
      {
        internalType: "contract IERC20",
        name: "",
        type: "address",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_fee",
        type: "uint256",
      },
    ],
    name: "setFee",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "bool",
        name: "_value",
        type: "bool",
      },
    ],
    name: "setPaused",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_reward",
        type: "address",
      },
    ],
    name: "setRewardToken",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "newOwner",
        type: "address",
      },
    ],
    name: "transferOwnership",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_user",
        type: "address",
      },
      {
        internalType: "uint256",
        name: "_reward",
        type: "uint256",
      },
    ],
    name: "updateReward",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [],
    name: "withdraw",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
];

// export const testAddress = "0xC596f5d6f5A55Cf134cD64849C585e4878450d09";
export const address = "0x33b3dA36A534eD253F35884746598A75927e7122";



================================================
FILE: src/blockchain/JBC/Distributor/claim.ts
================================================
import { abi, address } from "./abi";
import { Address, useContractWrite } from "wagmi";
import { useState } from "react";
import { viem, viemJBC } from "~/server/api/services/viem.service";
import { useChainId } from "wagmi";
import { useSwitchNetwork } from "wagmi";

export const useClaim = () => {
  const chainId = useChainId();
  const { switchNetwork } = useSwitchNetwork();
  const { isLoading, isError, isSuccess, write } = useContractWrite({
    address: address as Address,
    abi,
    functionName: "claim",
  });

  const claim = () => {
    if (chainId != 8899) {
      switchNetwork!(8899);
    }
    write();
  };

  return {
    claim,
    claiming: isLoading,
    claimed: isSuccess,
    claimingError: isError,
  };
};

export const useClaimedEvent = (owner: string) => {
  const [claimed, setClaimed] = useState<boolean>(false);

  viemJBC.watchContractEvent({
    address: address,
    abi,
    eventName: "Claimed",
    onLogs: (log: any[]) => {
      // console.log("log: ", log[0]);
      if (log[0].args.user == owner) {
        setClaimed(true);
      }
    },
  });

  const resetClaimed = () => {
    setClaimed(false);
  };

  return {
    claimedEvent: claimed,
    resetClaimed,
  };
};



================================================
FILE: src/blockchain/JBC/DistributorWhitelist/abi.ts
================================================
export const abi = [
  {
    inputs: [
      {
        internalType: "address",
        name: "_rewardToken",
        type: "address",
      },
      {
        internalType: "address",
        name: "_feeCollector",
        type: "address",
      },
      {
        internalType: "uint256",
        name: "_tokenSupply",
        type: "uint256",
      },
      {
        internalType: "uint256",
        name: "_rewardAmount",
        type: "uint256",
      },
    ],
    stateMutability: "nonpayable",
    type: "constructor",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "user",
        type: "address",
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amount",
        type: "uint256",
      },
    ],
    name: "ClaimedEvent",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "previousOwner",
        type: "address",
      },
      {
        indexed: true,
        internalType: "address",
        name: "newOwner",
        type: "address",
      },
    ],
    name: "OwnershipTransferred",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "user",
        type: "address",
      },
      {
        indexed: false,
        internalType: "uint256[]",
        name: "tokenIds",
        type: "uint256[]",
      },
    ],
    name: "UpdateRewardEvent",
    type: "event",
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_amount",
        type: "uint256",
      },
    ],
    name: "calculateFee",
    outputs: [
      {
        internalType: "uint256",
        name: "feeRate",
        type: "uint256",
      },
      {
        internalType: "uint256",
        name: "payout",
        type: "uint256",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [],
    name: "claim",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256",
      },
    ],
    name: "claimedToken",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [],
    name: "fee",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [],
    name: "getBalance",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_user",
        type: "address",
      },
    ],
    name: "getClaimableOf",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [],
    name: "getRewardPerToken",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "uint256[]",
        name: "_tokenIds",
        type: "uint256[]",
      },
    ],
    name: "isApprovable",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [],
    name: "owner",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [],
    name: "paused",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [],
    name: "renounceOwnership",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_user",
        type: "address",
      },
    ],
    name: "resetReward",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [],
    name: "rewardToken",
    outputs: [
      {
        internalType: "contract IERC20",
        name: "",
        type: "address",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256",
      },
      {
        internalType: "bool",
        name: "_value",
        type: "bool",
      },
    ],
    name: "setClaimToken",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_fee",
        type: "uint256",
      },
    ],
    name: "setFee",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "bool",
        name: "_value",
        type: "bool",
      },
    ],
    name: "setPaused",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_reward",
        type: "address",
      },
    ],
    name: "setRewardToken",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "newOwner",
        type: "address",
      },
    ],
    name: "transferOwnership",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "uint256[]",
        name: "_tokenIds",
        type: "uint256[]",
      },
    ],
    name: "updateClaimedTokenIds",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_user",
        type: "address",
      },
      {
        internalType: "uint256[]",
        name: "_tokenIds",
        type: "uint256[]",
      },
    ],
    name: "updateReward",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "",
        type: "address",
      },
    ],
    name: "userToRewards",
    outputs: [
      {
        internalType: "uint256",
        name: "updatedAt",
        type: "uint256",
      },
      {
        internalType: "uint256",
        name: "claimedAt",
        type: "uint256",
      },
      {
        internalType: "uint256",
        name: "claimableAmount",
        type: "uint256",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [],
    name: "withdraw",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
];
// export const abi = [
//   {
//     inputs: [
//       {
//         internalType: "address",
//         name: "_rewardToken",
//         type: "address",
//       },
//       {
//         internalType: "address",
//         name: "_feeCollector",
//         type: "address",
//       },
//     ],
//     stateMutability: "nonpayable",
//     type: "constructor",
//   },
//   {
//     anonymous: false,
//     inputs: [
//       {
//         indexed: true,
//         internalType: "address",
//         name: "user",
//         type: "address",
//       },
//       {
//         indexed: false,
//         internalType: "uint256",
//         name: "amount",
//         type: "uint256",
//       },
//     ],
//     name: "ClaimedEvent",
//     type: "event",
//   },
//   {
//     anonymous: false,
//     inputs: [
//       {
//         indexed: true,
//         internalType: "address",
//         name: "previousOwner",
//         type: "address",
//       },
//       {
//         indexed: true,
//         internalType: "address",
//         name: "newOwner",
//         type: "address",
//       },
//     ],
//     name: "OwnershipTransferred",
//     type: "event",
//   },
//   {
//     anonymous: false,
//     inputs: [
//       {
//         indexed: true,
//         internalType: "address",
//         name: "user",
//         type: "address",
//       },
//     ],
//     name: "UpdateRewardEvent",
//     type: "event",
//   },
//   {
//     inputs: [
//       {
//         internalType: "uint256",
//         name: "_amount",
//         type: "uint256",
//       },
//     ],
//     name: "calculateFee",
//     outputs: [
//       {
//         internalType: "uint256",
//         name: "feeRate",
//         type: "uint256",
//       },
//       {
//         internalType: "uint256",
//         name: "payout",
//         type: "uint256",
//       },
//     ],
//     stateMutability: "view",
//     type: "function",
//   },
//   {
//     inputs: [],
//     name: "claim",
//     outputs: [],
//     stateMutability: "nonpayable",
//     type: "function",
//   },
//   {
//     inputs: [],
//     name: "getBalance",
//     outputs: [
//       {
//         internalType: "uint256",
//         name: "",
//         type: "uint256",
//       },
//     ],
//     stateMutability: "view",
//     type: "function",
//   },
//   {
//     inputs: [
//       {
//         internalType: "address",
//         name: "_user",
//         type: "address",
//       },
//     ],
//     name: "getClaimableOf",
//     outputs: [
//       {
//         internalType: "uint256",
//         name: "",
//         type: "uint256",
//       },
//     ],
//     stateMutability: "view",
//     type: "function",
//   },
//   {
//     inputs: [
//       {
//         internalType: "address",
//         name: "_user",
//         type: "address",
//       },
//     ],
//     name: "isClaimable",
//     outputs: [
//       {
//         internalType: "bool",
//         name: "",
//         type: "bool",
//       },
//     ],
//     stateMutability: "view",
//     type: "function",
//   },
//   {
//     inputs: [],
//     name: "owner",
//     outputs: [
//       {
//         internalType: "address",
//         name: "",
//         type: "address",
//       },
//     ],
//     stateMutability: "view",
//     type: "function",
//   },
//   {
//     inputs: [],
//     name: "paused",
//     outputs: [
//       {
//         internalType: "bool",
//         name: "",
//         type: "bool",
//       },
//     ],
//     stateMutability: "view",
//     type: "function",
//   },
//   {
//     inputs: [],
//     name: "renounceOwnership",
//     outputs: [],
//     stateMutability: "nonpayable",
//     type: "function",
//   },
//   {
//     inputs: [
//       {
//         internalType: "address",
//         name: "_user",
//         type: "address",
//       },
//     ],
//     name: "resetReward",
//     outputs: [],
//     stateMutability: "nonpayable",
//     type: "function",
//   },
//   {
//     inputs: [],
//     name: "rewardToken",
//     outputs: [
//       {
//         internalType: "contract IERC20",
//         name: "",
//         type: "address",
//       },
//     ],
//     stateMutability: "view",
//     type: "function",
//   },
//   {
//     inputs: [
//       {
//         internalType: "uint256",
//         name: "_fee",
//         type: "uint256",
//       },
//     ],
//     name: "setFee",
//     outputs: [],
//     stateMutability: "nonpayable",
//     type: "function",
//   },
//   {
//     inputs: [
//       {
//         internalType: "bool",
//         name: "_value",
//         type: "bool",
//       },
//     ],
//     name: "setPaused",
//     outputs: [],
//     stateMutability: "nonpayable",
//     type: "function",
//   },
//   {
//     inputs: [
//       {
//         internalType: "address",
//         name: "_reward",
//         type: "address",
//       },
//     ],
//     name: "setRewardToken",
//     outputs: [],
//     stateMutability: "nonpayable",
//     type: "function",
//   },
//   {
//     inputs: [
//       {
//         internalType: "address",
//         name: "newOwner",
//         type: "address",
//       },
//     ],
//     name: "transferOwnership",
//     outputs: [],
//     stateMutability: "nonpayable",
//     type: "function",
//   },
//   {
//     inputs: [
//       {
//         internalType: "address",
//         name: "_user",
//         type: "address",
//       },
//       {
//         internalType: "uint256",
//         name: "_reward",
//         type: "uint256",
//       },
//       {
//         internalType: "uint256[]",
//         name: "_tokenIds",
//         type: "uint256[]",
//       },
//     ],
//     name: "updateReward",
//     outputs: [],
//     stateMutability: "nonpayable",
//     type: "function",
//   },
//   {
//     inputs: [],
//     name: "withdraw",
//     outputs: [],
//     stateMutability: "nonpayable",
//     type: "function",
//   },
// ];

// export const address = "0xe67E0CbEFd9cb5Ba0e63aB24312bB28Efeb39b62";
export const address = "0xF310aeF56A5ab07DE8B4F6BeFcC0E09036cb76E5";



================================================
FILE: src/blockchain/JBC/DistributorWhitelist/claim.ts
================================================
import { abi, address } from "./abi";
import { Address, useContractWrite } from "wagmi";
import { useState } from "react";
import { viemJBC } from "~/server/api/services/viem.service";
import { useChainId } from "wagmi";
import { useSwitchNetwork } from "wagmi";

export const useClaimWhitelist = () => {
  const chainId = useChainId();
  const { switchNetwork } = useSwitchNetwork();
  const { isLoading, isError, isSuccess, write } = useContractWrite({
    address: address as Address,
    abi,
    functionName: "claim",
  });

  const claim = () => {
    if (chainId != 8899) {
      switchNetwork!(8899);
    }
    write();
  };

  return {
    claim,
    claiming: isLoading,
    claimed: isSuccess,
    claimingError: isError,
  };
};

export const useUpdateRewardEvent = (owner: string) => {
  const [updateReward, setUpdateReward] = useState<boolean>(false);

  viemJBC.watchContractEvent({
    address: address,
    abi,
    eventName: "UpdateRewardEvent",
    onLogs: (log: any[]) => {
      // console.log("log: ", log[0]);
      if (log[0].args.user == owner) {
        setUpdateReward(true);
      }
    },
  });

  const resetUpdateReward = () => {
    setUpdateReward(false);
  };

  return {
    updateRewardEvent: updateReward,
    resetUpdateReward,
  };
};

export const useClaimedEvent = (owner: string) => {
  const [claimed, setClaimed] = useState<boolean>(false);

  viemJBC.watchContractEvent({
    address: address,
    abi,
    eventName: "ClaimedEvent",
    onLogs: (log: any[]) => {
      // console.log("log: ", log[0]);
      if (log[0].args.user == owner) {
        setClaimed(true);
      }
    },
  });

  const resetClaimed = () => {
    setClaimed(false);
  };

  return {
    claimedEvent: claimed,
    resetClaimed,
  };
};



================================================
FILE: src/blockchain/Mine/abi.ts
================================================
export const abi = [
  {
    inputs: [
      {
        internalType: "address",
        name: "_token",
        type: "address",
      },
      {
        internalType: "uint256",
        name: "_amount",
        type: "uint256",
      },
    ],
    name: "emergencyRewardTokenWithdraw",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "contract IERC721",
        name: "_digdragon",
        type: "address",
      },
      {
        internalType: "contract IERC20",
        name: "_reward",
        type: "address",
      },
      {
        internalType: "contract IHashPowerStorage",
        name: "_hashPowerStorage",
        type: "address",
      },
      {
        internalType: "address",
        name: "_feeCollector",
        type: "address",
      },
      {
        internalType: "uint256",
        name: "_startBlock",
        type: "uint256",
      },
      {
        internalType: "uint256",
        name: "_rewardPerBlock",
        type: "uint256",
      },
      {
        internalType: "uint256",
        name: "_rewardEndBlock",
        type: "uint256",
      },
    ],
    stateMutability: "nonpayable",
    type: "constructor",
  },
  {
    inputs: [],
    name: "ZeroStakedHashPowerAmount",
    type: "error",
  },
  {
    inputs: [],
    name: "ZeroStakedTokens",
    type: "error",
  },
  {
    anonymous: false,
    inputs: [],
    name: "EmergencyRewardWithDrawn",
    type: "event",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_owner",
        type: "address",
      },
    ],
    name: "emergencyUnstake",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    anonymous: false,
    inputs: [],
    name: "EmergencyUnstaked",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "newStorage",
        type: "address",
      },
    ],
    name: "HashPowerStorageChanged",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [],
    name: "MinePaused",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "_newRewardBlock",
        type: "uint256",
      },
    ],
    name: "NewRewardEndBlockSet",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "_newRewardPerBlock",
        type: "uint256",
      },
    ],
    name: "NewRewardPerBlockSet",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "_startBlock",
        type: "uint256",
      },
    ],
    name: "NewStartBlockSet",
    type: "event",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "",
        type: "address",
      },
      {
        internalType: "address",
        name: "",
        type: "address",
      },
      {
        internalType: "uint256",
        name: "",
        type: "uint256",
      },
      {
        internalType: "bytes",
        name: "",
        type: "bytes",
      },
    ],
    name: "onERC721Received",
    outputs: [
      {
        internalType: "bytes4",
        name: "",
        type: "bytes4",
      },
    ],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "previousOwner",
        type: "address",
      },
      {
        indexed: true,
        internalType: "address",
        name: "newOwner",
        type: "address",
      },
    ],
    name: "OwnershipTransferred",
    type: "event",
  },
  {
    inputs: [],
    name: "renounceOwnership",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "stopBlock",
        type: "uint256",
      },
    ],
    name: "RewardDistributionStopped",
    type: "event",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_collector",
        type: "address",
      },
    ],
    name: "setFeeCollector",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "contract IHashPowerStorage",
        name: "_storage",
        type: "address",
      },
    ],
    name: "setHashPowerStorage",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_miner",
        type: "address",
      },
    ],
    name: "setMinerAddress",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "miner",
        type: "address",
      },
    ],
    name: "SetNewMiner",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "newReward",
        type: "address",
      },
    ],
    name: "SetNewReward",
    type: "event",
  },
  {
    inputs: [
      {
        internalType: "bool",
        name: "_value",
        type: "bool",
      },
    ],
    name: "setPause",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "contract IERC20",
        name: "_newReward",
        type: "address",
      },
    ],
    name: "setRewardAddress",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_rewardEndBlock",
        type: "uint256",
      },
    ],
    name: "setRewardEndBlock",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_rewardPerBlock",
        type: "uint256",
      },
    ],
    name: "setRewardPerBlock",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_startBlock",
        type: "uint256",
      },
    ],
    name: "setStartBlock",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "uint256[]",
        name: "_tokenIds",
        type: "uint256[]",
      },
    ],
    name: "stake",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "owner",
        type: "address",
      },
      {
        indexed: false,
        internalType: "uint256[]",
        name: "tokenIds",
        type: "uint256[]",
      },
    ],
    name: "Staked",
    type: "event",
  },
  {
    inputs: [],
    name: "stopRewardDistribution",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "newOwner",
        type: "address",
      },
    ],
    name: "transferOwnership",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "uint256[]",
        name: "_tokenIds",
        type: "uint256[]",
      },
    ],
    name: "unstake",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "owner",
        type: "address",
      },
      {
        indexed: false,
        internalType: "uint256[]",
        name: "tokenIds",
        type: "uint256[]",
      },
    ],
    name: "Unstaked",
    type: "event",
  },
  {
    inputs: [],
    name: "updatePool",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [],
    name: "withdrawReward",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [],
    name: "getMineInfo",
    outputs: [
      {
        components: [
          {
            internalType: "address",
            name: "digdragon",
            type: "address",
          },
          {
            internalType: "address",
            name: "reward",
            type: "address",
          },
          {
            internalType: "address",
            name: "hashStorage",
            type: "address",
          },
          {
            internalType: "address",
            name: "feeCollector",
            type: "address",
          },
          {
            internalType: "uint256",
            name: "fee",
            type: "uint256",
          },
          {
            internalType: "uint256",
            name: "startBlock",
            type: "uint256",
          },
          {
            internalType: "uint256",
            name: "rewardEndBlock",
            type: "uint256",
          },
          {
            internalType: "uint256",
            name: "rewardPerBlock",
            type: "uint256",
          },
          {
            internalType: "uint256",
            name: "accTokenPerShare",
            type: "uint256",
          },
          {
            internalType: "uint256",
            name: "rewardsForWithdrawal",
            type: "uint256",
          },
          {
            internalType: "uint256",
            name: "totalStakedTokens",
            type: "uint256",
          },
          {
            internalType: "uint256",
            name: "totalHashPower",
            type: "uint256",
          },
        ],
        internalType: "struct DigDragonMine.MineInfo",
        name: "info",
        type: "tuple",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_from",
        type: "uint256",
      },
      {
        internalType: "uint256",
        name: "_to",
        type: "uint256",
      },
    ],
    name: "getMultiplier",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_miner",
        type: "address",
      },
    ],
    name: "getRewardDebt",
    outputs: [
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_miner",
        type: "address",
      },
    ],
    name: "getUserInfo",
    outputs: [
      {
        components: [
          {
            internalType: "uint256[]",
            name: "stakedTokenIds",
            type: "uint256[]",
          },
          {
            internalType: "uint256",
            name: "stakedHashPowerAmount",
            type: "uint256",
          },
          {
            internalType: "uint256",
            name: "lastIn",
            type: "uint256",
          },
          {
            internalType: "uint256",
            name: "lastOut",
            type: "uint256",
          },
        ],
        internalType: "struct DigDragonMine.Miner",
        name: "userInfo",
        type: "tuple",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_miner",
        type: "address",
      },
    ],
    name: "getUserStakedHashPowerAmount",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_miner",
        type: "address",
      },
    ],
    name: "getUserStakedTokens",
    outputs: [
      {
        internalType: "uint256[]",
        name: "",
        type: "uint256[]",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [],
    name: "isPaused",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [],
    name: "lastRewardBlock",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [],
    name: "owner",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_miner",
        type: "address",
      },
    ],
    name: "pendingReward",
    outputs: [
      {
        internalType: "contract IERC20",
        name: "",
        type: "address",
      },
      {
        internalType: "uint256",
        name: "",
        type: "uint256",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [],
    name: "totalHashPower",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [],
    name: "totalStakedTokens",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
];

// export const address = "0x6d2d548CB51D82bc9C850fc1F1315B8a4665666F";
export const address = "0x41d45dF6FBEEC5DC70D53Fbbe92F3ccBA9C45250"; //Mine 1 (BUG)

// export const mineAddress = {
//   mine1: "0x41d45dF6FBEEC5DC70D53Fbbe92F3ccBA9C45250",
//   mine2: "0x0FED565a2f8166DBa6Ff75698e1056e284eD4f7D",
// }; //Mine 2 (v2)



================================================
FILE: src/blockchain/Mine/abi2.ts
================================================
export const abi = [
  {
    type: "constructor",
    stateMutability: "nonpayable",
    inputs: [
      { type: "address", name: "_digdragon", internalType: "contract IERC721" },
      { type: "address", name: "_reward", internalType: "contract IERC20" },
      {
        type: "address",
        name: "_hashPowerStorage",
        internalType: "contract IHashPowerStorage",
      },
      { type: "address", name: "_feeCollector", internalType: "address" },
      { type: "uint256", name: "_startBlock", internalType: "uint256" },
      { type: "uint256", name: "_rewardPerBlock", internalType: "uint256" },
      { type: "uint256", name: "_rewardEndBlock", internalType: "uint256" },
    ],
  },
  { type: "error", name: "ZeroStakedHashPowerAmount", inputs: [] },
  { type: "error", name: "ZeroStakedTokens", inputs: [] },
  {
    type: "event",
    name: "Earned",
    inputs: [
      {
        type: "address",
        name: "miner",
        internalType: "address",
        indexed: true,
      },
      {
        type: "uint256",
        name: "earned",
        internalType: "uint256",
        indexed: false,
      },
    ],
    anonymous: false,
  },
  {
    type: "event",
    name: "EmergencyRewardWithDrawn",
    inputs: [],
    anonymous: false,
  },
  { type: "event", name: "EmergencyUnstaked", inputs: [], anonymous: false },
  {
    type: "event",
    name: "HashPowerStorageChanged",
    inputs: [
      {
        type: "address",
        name: "newStorage",
        internalType: "address",
        indexed: false,
      },
    ],
    anonymous: false,
  },
  { type: "event", name: "MinePaused", inputs: [], anonymous: false },
  {
    type: "event",
    name: "NewRewardEndBlockSet",
    inputs: [
      {
        type: "uint256",
        name: "_newRewardBlock",
        internalType: "uint256",
        indexed: false,
      },
    ],
    anonymous: false,
  },
  {
    type: "event",
    name: "NewRewardPerBlockSet",
    inputs: [
      {
        type: "uint256",
        name: "_newRewardPerBlock",
        internalType: "uint256",
        indexed: false,
      },
    ],
    anonymous: false,
  },
  {
    type: "event",
    name: "NewStartBlockSet",
    inputs: [
      {
        type: "uint256",
        name: "_startBlock",
        internalType: "uint256",
        indexed: false,
      },
    ],
    anonymous: false,
  },
  {
    type: "event",
    name: "OwnershipTransferred",
    inputs: [
      {
        type: "address",
        name: "previousOwner",
        internalType: "address",
        indexed: true,
      },
      {
        type: "address",
        name: "newOwner",
        internalType: "address",
        indexed: true,
      },
    ],
    anonymous: false,
  },
  {
    type: "event",
    name: "RewardDistributionStopped",
    inputs: [
      {
        type: "uint256",
        name: "stopBlock",
        internalType: "uint256",
        indexed: false,
      },
    ],
    anonymous: false,
  },
  {
    type: "event",
    name: "SetNewMiner",
    inputs: [
      {
        type: "address",
        name: "miner",
        internalType: "address",
        indexed: false,
      },
    ],
    anonymous: false,
  },
  {
    type: "event",
    name: "SetNewReward",
    inputs: [
      {
        type: "address",
        name: "newReward",
        internalType: "address",
        indexed: false,
      },
    ],
    anonymous: false,
  },
  {
    type: "event",
    name: "Staked",
    inputs: [
      {
        type: "address",
        name: "owner",
        internalType: "address",
        indexed: true,
      },
      {
        type: "uint256[]",
        name: "tokenIds",
        internalType: "uint256[]",
        indexed: false,
      },
    ],
    anonymous: false,
  },
  {
    type: "event",
    name: "Unstaked",
    inputs: [
      {
        type: "address",
        name: "owner",
        internalType: "address",
        indexed: true,
      },
      {
        type: "uint256[]",
        name: "tokenIds",
        internalType: "uint256[]",
        indexed: false,
      },
    ],
    anonymous: false,
  },
  {
    type: "function",
    stateMutability: "nonpayable",
    outputs: [],
    name: "earnReward",
    inputs: [],
  },
  {
    type: "function",
    stateMutability: "nonpayable",
    outputs: [],
    name: "emergencyRewardTokenWithdraw",
    inputs: [
      { type: "address", name: "_token", internalType: "address" },
      { type: "uint256", name: "_amount", internalType: "uint256" },
    ],
  },
  {
    type: "function",
    stateMutability: "nonpayable",
    outputs: [],
    name: "emergencyUnstake",
    inputs: [{ type: "address", name: "_owner", internalType: "address" }],
  },
  {
    type: "function",
    stateMutability: "view",
    outputs: [
      {
        type: "tuple",
        name: "info",
        internalType: "struct DigDragonMineV2.MineInfo",
        components: [
          { type: "address", name: "digdragon", internalType: "address" },
          { type: "address", name: "reward", internalType: "address" },
          { type: "address", name: "hashStorage", internalType: "address" },
          { type: "address", name: "feeCollector", internalType: "address" },
          { type: "uint256", name: "fee", internalType: "uint256" },
          { type: "uint256", name: "startBlock", internalType: "uint256" },
          { type: "uint256", name: "rewardEndBlock", internalType: "uint256" },
          { type: "uint256", name: "rewardPerBlock", internalType: "uint256" },
          {
            type: "uint256",
            name: "accTokenPerShare",
            internalType: "uint256",
          },
          {
            type: "uint256",
            name: "rewardsForWithdrawal",
            internalType: "uint256",
          },
          {
            type: "uint256",
            name: "totalStakedTokens",
            internalType: "uint256",
          },
          { type: "uint256", name: "totalHashPower", internalType: "uint256" },
        ],
      },
    ],
    name: "getMineInfo",
    inputs: [],
  },
  {
    type: "function",
    stateMutability: "view",
    outputs: [{ type: "uint256", name: "amount", internalType: "uint256" }],
    name: "getRewardDebt",
    inputs: [{ type: "address", name: "_miner", internalType: "address" }],
  },
  {
    type: "function",
    stateMutability: "view",
    outputs: [
      {
        type: "tuple",
        name: "userInfo",
        internalType: "struct DigDragonMineV2.Miner",
        components: [
          {
            type: "uint256[]",
            name: "stakedTokenIds",
            internalType: "uint256[]",
          },
          {
            type: "uint256",
            name: "stakedHashPowerAmount",
            internalType: "uint256",
          },
          { type: "uint256", name: "lastIn", internalType: "uint256" },
          { type: "uint256", name: "lastOut", internalType: "uint256" },
        ],
      },
    ],
    name: "getUserInfo",
    inputs: [{ type: "address", name: "_miner", internalType: "address" }],
  },
  {
    type: "function",
    stateMutability: "view",
    outputs: [{ type: "uint256", name: "", internalType: "uint256" }],
    name: "getUserStakedHashPowerAmount",
    inputs: [{ type: "address", name: "_miner", internalType: "address" }],
  },
  {
    type: "function",
    stateMutability: "view",
    outputs: [{ type: "uint256[]", name: "", internalType: "uint256[]" }],
    name: "getUserStakedTokens",
    inputs: [{ type: "address", name: "_miner", internalType: "address" }],
  },
  {
    type: "function",
    stateMutability: "view",
    outputs: [{ type: "bool", name: "", internalType: "bool" }],
    name: "isPaused",
    inputs: [],
  },
  {
    type: "function",
    stateMutability: "nonpayable",
    outputs: [{ type: "bytes4", name: "", internalType: "bytes4" }],
    name: "onERC721Received",
    inputs: [
      { type: "address", name: "", internalType: "address" },
      { type: "address", name: "", internalType: "address" },
      { type: "uint256", name: "", internalType: "uint256" },
      { type: "bytes", name: "", internalType: "bytes" },
    ],
  },
  {
    type: "function",
    stateMutability: "view",
    outputs: [{ type: "address", name: "", internalType: "address" }],
    name: "owner",
    inputs: [],
  },
  {
    type: "function",
    stateMutability: "view",
    outputs: [{ type: "uint256", name: "", internalType: "uint256" }],
    name: "pendingReward",
    inputs: [{ type: "address", name: "_miner", internalType: "address" }],
  },
  {
    type: "function",
    stateMutability: "nonpayable",
    outputs: [],
    name: "renounceOwnership",
    inputs: [],
  },
  {
    type: "function",
    stateMutability: "view",
    outputs: [{ type: "uint256", name: "", internalType: "uint256" }],
    name: "rewardPerHashPower",
    inputs: [],
  },
  {
    type: "function",
    stateMutability: "nonpayable",
    outputs: [],
    name: "setFeeCollector",
    inputs: [{ type: "address", name: "_collector", internalType: "address" }],
  },
  {
    type: "function",
    stateMutability: "nonpayable",
    outputs: [],
    name: "setHashPowerStorage",
    inputs: [
      {
        type: "address",
        name: "_storage",
        internalType: "contract IHashPowerStorage",
      },
    ],
  },
  {
    type: "function",
    stateMutability: "nonpayable",
    outputs: [],
    name: "setMinerAddress",
    inputs: [{ type: "address", name: "_miner", internalType: "address" }],
  },
  {
    type: "function",
    stateMutability: "nonpayable",
    outputs: [],
    name: "setPause",
    inputs: [{ type: "bool", name: "_value", internalType: "bool" }],
  },
  {
    type: "function",
    stateMutability: "nonpayable",
    outputs: [],
    name: "setRewardAddress",
    inputs: [
      { type: "address", name: "_newReward", internalType: "contract IERC20" },
    ],
  },
  {
    type: "function",
    stateMutability: "nonpayable",
    outputs: [],
    name: "setRewardEndBlock",
    inputs: [
      { type: "uint256", name: "_rewardEndBlock", internalType: "uint256" },
    ],
  },
  {
    type: "function",
    stateMutability: "nonpayable",
    outputs: [],
    name: "setRewardPerBlock",
    inputs: [
      { type: "uint256", name: "_rewardPerBlock", internalType: "uint256" },
    ],
  },
  {
    type: "function",
    stateMutability: "nonpayable",
    outputs: [],
    name: "setStartBlock",
    inputs: [{ type: "uint256", name: "_startBlock", internalType: "uint256" }],
  },
  {
    type: "function",
    stateMutability: "nonpayable",
    outputs: [],
    name: "stake",
    inputs: [
      { type: "uint256[]", name: "_tokenIds", internalType: "uint256[]" },
    ],
  },
  {
    type: "function",
    stateMutability: "nonpayable",
    outputs: [],
    name: "stopRewardDistribution",
    inputs: [],
  },
  {
    type: "function",
    stateMutability: "view",
    outputs: [{ type: "uint256", name: "", internalType: "uint256" }],
    name: "totalHashPower",
    inputs: [],
  },
  {
    type: "function",
    stateMutability: "view",
    outputs: [{ type: "uint256", name: "", internalType: "uint256" }],
    name: "totalStakedTokens",
    inputs: [],
  },
  {
    type: "function",
    stateMutability: "nonpayable",
    outputs: [],
    name: "transferOwnership",
    inputs: [{ type: "address", name: "newOwner", internalType: "address" }],
  },
  {
    type: "function",
    stateMutability: "nonpayable",
    outputs: [],
    name: "unstake",
    inputs: [
      { type: "uint256[]", name: "_tokenIds", internalType: "uint256[]" },
    ],
  },
];

// export const address1 = "0x55448C24DB10822DF8736661FbEaC0f30e182b85";
// export const address2 = "0x70241e08CC1735B9b0B3568C42EE8Ce10aD49339";
// export const address3 = "0x278067Fa98664648D45806705D00782a1fcb8e85";
export const address4 = "0x245E1B0207D9A2eb323766722a38FbDD129fF772";
export const address5 = "0xA6E034CeF24184DCb2Eed382adA63F87303F1e43";
export const address6 = "0xDc8e042714F948020255f81d970fcEB2337124d2";
export const address7 = "0x3fE5CD7F57824B79450b4f4202bd06acb9D50e0e";
export const address8 = "0x1c062c30f4C7c07ab2C60C4C4F727586fcB7c5aC";



================================================
FILE: src/blockchain/Mine/abi3.ts
================================================
export const abi = [
  {
    inputs: [
      {
        internalType: "contract IERC721",
        name: "_digdragon",
        type: "address",
      },
      {
        internalType: "contract IHashPowerStorage",
        name: "_hashPowerStorage",
        type: "address",
      },
      {
        internalType: "address",
        name: "_feeCollector",
        type: "address",
      },
      {
        internalType: "uint256",
        name: "_startBlock",
        type: "uint256",
      },
      {
        internalType: "uint256",
        name: "_rewardPerBlock",
        type: "uint256",
      },
      {
        internalType: "uint256",
        name: "_rewardEndBlock",
        type: "uint256",
      },
    ],
    stateMutability: "nonpayable",
    type: "constructor",
  },
  {
    inputs: [],
    name: "ZeroStakedHashPowerAmount",
    type: "error",
  },
  {
    inputs: [],
    name: "ZeroStakedTokens",
    type: "error",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "miner",
        type: "address",
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "earned",
        type: "uint256",
      },
    ],
    name: "Earned",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [],
    name: "EmergencyRewardWithDrawn",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [],
    name: "EmergencyUnstaked",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "newStorage",
        type: "address",
      },
    ],
    name: "HashPowerStorageChanged",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [],
    name: "MinePaused",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "_newRewardBlock",
        type: "uint256",
      },
    ],
    name: "NewRewardEndBlockSet",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "_newRewardPerBlock",
        type: "uint256",
      },
    ],
    name: "NewRewardPerBlockSet",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "_startBlock",
        type: "uint256",
      },
    ],
    name: "NewStartBlockSet",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "previousOwner",
        type: "address",
      },
      {
        indexed: true,
        internalType: "address",
        name: "newOwner",
        type: "address",
      },
    ],
    name: "OwnershipTransferred",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "stopBlock",
        type: "uint256",
      },
    ],
    name: "RewardDistributionStopped",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "miner",
        type: "address",
      },
    ],
    name: "SetNewMiner",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "owner",
        type: "address",
      },
      {
        indexed: false,
        internalType: "uint256[]",
        name: "tokenIds",
        type: "uint256[]",
      },
    ],
    name: "Staked",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "owner",
        type: "address",
      },
      {
        indexed: false,
        internalType: "uint256[]",
        name: "tokenIds",
        type: "uint256[]",
      },
    ],
    name: "Unstaked",
    type: "event",
  },
  {
    inputs: [],
    name: "earnReward",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_token",
        type: "address",
      },
      {
        internalType: "uint256",
        name: "_amount",
        type: "uint256",
      },
    ],
    name: "emergencyRewardTokenWithdraw",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_owner",
        type: "address",
      },
    ],
    name: "emergencyUnstake",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [],
    name: "emergencywithdrawKUB",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [],
    name: "getBalance",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [],
    name: "getMineInfo",
    outputs: [
      {
        components: [
          {
            internalType: "address",
            name: "digdragon",
            type: "address",
          },
          {
            internalType: "address",
            name: "reward",
            type: "address",
          },
          {
            internalType: "address",
            name: "hashStorage",
            type: "address",
          },
          {
            internalType: "address",
            name: "feeCollector",
            type: "address",
          },
          {
            internalType: "uint256",
            name: "fee",
            type: "uint256",
          },
          {
            internalType: "uint256",
            name: "startBlock",
            type: "uint256",
          },
          {
            internalType: "uint256",
            name: "rewardEndBlock",
            type: "uint256",
          },
          {
            internalType: "uint256",
            name: "rewardPerBlock",
            type: "uint256",
          },
          {
            internalType: "uint256",
            name: "accTokenPerShare",
            type: "uint256",
          },
          {
            internalType: "uint256",
            name: "rewardsForWithdrawal",
            type: "uint256",
          },
          {
            internalType: "uint256",
            name: "totalStakedTokens",
            type: "uint256",
          },
          {
            internalType: "uint256",
            name: "totalHashPower",
            type: "uint256",
          },
        ],
        internalType: "struct DigDragonMineKUB.MineInfo",
        name: "info",
        type: "tuple",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_miner",
        type: "address",
      },
    ],
    name: "getRewardDebt",
    outputs: [
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_miner",
        type: "address",
      },
    ],
    name: "getUserInfo",
    outputs: [
      {
        components: [
          {
            internalType: "uint256[]",
            name: "stakedTokenIds",
            type: "uint256[]",
          },
          {
            internalType: "uint256",
            name: "stakedHashPowerAmount",
            type: "uint256",
          },
          {
            internalType: "uint256",
            name: "lastIn",
            type: "uint256",
          },
          {
            internalType: "uint256",
            name: "lastOut",
            type: "uint256",
          },
        ],
        internalType: "struct DigDragonMineKUB.Miner",
        name: "userInfo",
        type: "tuple",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_miner",
        type: "address",
      },
    ],
    name: "getUserStakedHashPowerAmount",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_miner",
        type: "address",
      },
    ],
    name: "getUserStakedTokens",
    outputs: [
      {
        internalType: "uint256[]",
        name: "",
        type: "uint256[]",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [],
    name: "isPaused",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "",
        type: "address",
      },
      {
        internalType: "address",
        name: "",
        type: "address",
      },
      {
        internalType: "uint256",
        name: "",
        type: "uint256",
      },
      {
        internalType: "bytes",
        name: "",
        type: "bytes",
      },
    ],
    name: "onERC721Received",
    outputs: [
      {
        internalType: "bytes4",
        name: "",
        type: "bytes4",
      },
    ],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [],
    name: "owner",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_miner",
        type: "address",
      },
    ],
    name: "pendingReward",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [],
    name: "renounceOwnership",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [],
    name: "rewardPerHashPower",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_collector",
        type: "address",
      },
    ],
    name: "setFeeCollector",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "contract IHashPowerStorage",
        name: "_storage",
        type: "address",
      },
    ],
    name: "setHashPowerStorage",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_miner",
        type: "address",
      },
    ],
    name: "setMinerAddress",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "bool",
        name: "_value",
        type: "bool",
      },
    ],
    name: "setPause",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_rewardEndBlock",
        type: "uint256",
      },
    ],
    name: "setRewardEndBlock",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_rewardPerBlock",
        type: "uint256",
      },
    ],
    name: "setRewardPerBlock",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_startBlock",
        type: "uint256",
      },
    ],
    name: "setStartBlock",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "uint256[]",
        name: "_tokenIds",
        type: "uint256[]",
      },
    ],
    name: "stake",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [],
    name: "stopRewardDistribution",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [],
    name: "totalHashPower",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [],
    name: "totalStakedTokens",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "newOwner",
        type: "address",
      },
    ],
    name: "transferOwnership",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "uint256[]",
        name: "_tokenIds",
        type: "uint256[]",
      },
    ],
    name: "unstake",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    stateMutability: "payable",
    type: "receive",
  },
];

export const address1 = "0xf760e434C8567d19155D56E71eF5feF609e2B771";
export const address2 = "0x694c13E62907Fe78F8159234A76D1d7d680be4dD";
export const address3 = "0xD5163B7c12454Bf3d973bf3a9DA6EEB92463B9fA";
export const address9 = "0xf288E1305910a7079a7f1F5EA756eb8037c07B94";
export const address10 = "0x64B906B022bbFc472C0704B7F20dB7dc93A73a07";
export const address11 = "0xf2cC9566bF1e93f9bb3EBDF70eb663997A154C74";
export const address12 = "0xC5514eaF99c755AB17379b5D13B9015C5f0D3ff3";
export const address13 = "0x76F1fC64E13954eEa4430843935d5F5646c056F0";
export const address14 = "0x9Dc3B31216ca92F87418F8b994a16fBD128b7293";
export const address15 = "0xb041b24a91aAEe3201DbEa7e53FfFeEC51da88Be";
export const address16 = "0x9f5Ea988688BfAc248987DeF4E0B6138aE0D91B2";
export const address17 = "0x9B4D83A0057A593D7D924E2B6a8d002F17c28Fe2";



================================================
FILE: src/blockchain/Mine/stake.ts
================================================
import { abi, address } from "./abi";
import { Address, useContractWrite } from "wagmi";
import { useState } from "react";
import { viem } from "~/server/api/services/viem.service";

export const useStake = (mine: string) => {
  const { isLoading, isError, isSuccess, write } = useContractWrite({
    address: mine as Address,
    abi,
    functionName: "stake",
  });

  const stake = (tokenIds: number[]) => {
    if (tokenIds.length <= 0) return;
    write({ args: [tokenIds] });
  };

  return {
    stake,
    staking: isLoading,
    staked: isSuccess,
    stakingError: isError,
  };
};

export const useStakedEvent = (owner: string, mineAddress: Address) => {
  const [staked, setStaked] = useState<boolean>(false);

  viem.watchContractEvent({
    address: mineAddress,
    abi,
    eventName: "Staked",
    onLogs: (log: any[]) => {
      // console.log("log: ", log[0]);
      if (log[0].args.owner == owner) {
        setStaked(true);
      }
    },
  });

  const resetStaked = () => {
    setStaked(false);
  };

  return {
    stakedEvent: staked,
    resetStaked,
  };
};



================================================
FILE: src/blockchain/Mine/unstake.ts
================================================
import { abi, address } from "./abi";
import { Address, useContractEvent, useContractWrite } from "wagmi";
import { toast } from "react-toastify";
import { viem } from "~/server/api/services/viem.service";
import { useState } from "react";

export const useUnstake = (mine: string) => {
  const { isLoading, isError, isSuccess, write } = useContractWrite({
    address: mine as Address,
    abi,
    functionName: "unstake",
  });

  const unstake = (tokenIds: number[]) => {
    write({ args: [tokenIds] });
  };

  return {
    unstake,
    unstaking: isLoading,
    unstaked: isSuccess,
    unstakingError: isError,
  };
};

export const useUnStakedEvent = (owner: string, mineAddress: Address) => {
  const [unStaked, setUnStaked] = useState<boolean>(false);

  viem.watchContractEvent({
    address: mineAddress,
    abi,
    eventName: "Unstaked",
    onLogs: (log: any[]) => {
      // console.log("log: ", log[0]);
      if (log[0].args.owner == owner) {
        setUnStaked(true);
      }
    },
  });

  const resetUnStaked = () => {
    setUnStaked(false);
  };

  return {
    unStakedEvent: unStaked,
    resetUnStaked,
  };
};



================================================
FILE: src/blockchain/NFT/abi.ts
================================================
export const address = "0x7C80f994C724b0C8F834F4303C4f142004798219";
export const address2 = "0x3156e43ecE28c4ECc74D3df745d796C23f417876";
// export const address = "0x52853eDA884714dC35B5Ad9F493756C4b6692C49";
export const abi = [
  { type: "constructor", stateMutability: "nonpayable", inputs: [] },
  {
    type: "event",
    name: "Approval",
    inputs: [
      {
        type: "address",
        name: "owner",
        internalType: "address",
        indexed: true,
      },
      {
        type: "address",
        name: "approved",
        internalType: "address",
        indexed: true,
      },
      {
        type: "uint256",
        name: "tokenId",
        internalType: "uint256",
        indexed: true,
      },
    ],
    anonymous: false,
  },
  {
    type: "event",
    name: "ApprovalForAll",
    inputs: [
      {
        type: "address",
        name: "owner",
        internalType: "address",
        indexed: true,
      },
      {
        type: "address",
        name: "operator",
        internalType: "address",
        indexed: true,
      },
      { type: "bool", name: "approved", internalType: "bool", indexed: false },
    ],
    anonymous: false,
  },
  {
    type: "event",
    name: "Minted",
    inputs: [
      {
        type: "uint256",
        name: "_tokenId",
        internalType: "uint256",
        indexed: false,
      },
      { type: "address", name: "_to", internalType: "address", indexed: false },
    ],
    anonymous: false,
  },
  {
    type: "event",
    name: "OwnershipTransferred",
    inputs: [
      {
        type: "address",
        name: "previousOwner",
        internalType: "address",
        indexed: true,
      },
      {
        type: "address",
        name: "newOwner",
        internalType: "address",
        indexed: true,
      },
    ],
    anonymous: false,
  },
  {
    type: "event",
    name: "Transfer",
    inputs: [
      { type: "address", name: "from", internalType: "address", indexed: true },
      { type: "address", name: "to", internalType: "address", indexed: true },
      {
        type: "uint256",
        name: "tokenId",
        internalType: "uint256",
        indexed: true,
      },
    ],
    anonymous: false,
  },
  {
    type: "function",
    stateMutability: "nonpayable",
    outputs: [],
    name: "addWhitelist",
    inputs: [
      { type: "address[]", name: "_users", internalType: "address[]" },
      { type: "uint256[]", name: "_amounts", internalType: "uint256[]" },
    ],
  },
  {
    type: "function",
    stateMutability: "nonpayable",
    outputs: [],
    name: "approve",
    inputs: [
      { type: "address", name: "to", internalType: "address" },
      { type: "uint256", name: "tokenId", internalType: "uint256" },
    ],
  },
  {
    type: "function",
    stateMutability: "view",
    outputs: [{ type: "uint256", name: "", internalType: "uint256" }],
    name: "balanceOf",
    inputs: [{ type: "address", name: "owner", internalType: "address" }],
  },
  {
    type: "function",
    stateMutability: "view",
    outputs: [{ type: "address", name: "", internalType: "address" }],
    name: "getApproved",
    inputs: [{ type: "uint256", name: "tokenId", internalType: "uint256" }],
  },
  {
    type: "function",
    stateMutability: "view",
    outputs: [{ type: "uint256", name: "", internalType: "uint256" }],
    name: "getCurrentTokenId",
    inputs: [],
  },
  {
    type: "function",
    stateMutability: "view",
    outputs: [{ type: "bool", name: "", internalType: "bool" }],
    name: "isApprovedForAll",
    inputs: [
      { type: "address", name: "owner", internalType: "address" },
      { type: "address", name: "operator", internalType: "address" },
    ],
  },
  {
    type: "function",
    stateMutability: "nonpayable",
    outputs: [],
    name: "mint",
    inputs: [],
  },
  {
    type: "function",
    stateMutability: "view",
    outputs: [{ type: "string", name: "", internalType: "string" }],
    name: "name",
    inputs: [],
  },
  {
    type: "function",
    stateMutability: "view",
    outputs: [{ type: "address", name: "", internalType: "address" }],
    name: "owner",
    inputs: [],
  },
  {
    type: "function",
    stateMutability: "view",
    outputs: [{ type: "address", name: "", internalType: "address" }],
    name: "ownerOf",
    inputs: [{ type: "uint256", name: "tokenId", internalType: "uint256" }],
  },
  {
    type: "function",
    stateMutability: "nonpayable",
    outputs: [],
    name: "renounceOwnership",
    inputs: [],
  },
  {
    type: "function",
    stateMutability: "nonpayable",
    outputs: [],
    name: "safeTransferFrom",
    inputs: [
      { type: "address", name: "from", internalType: "address" },
      { type: "address", name: "to", internalType: "address" },
      { type: "uint256", name: "tokenId", internalType: "uint256" },
    ],
  },
  {
    type: "function",
    stateMutability: "nonpayable",
    outputs: [],
    name: "safeTransferFrom",
    inputs: [
      { type: "address", name: "from", internalType: "address" },
      { type: "address", name: "to", internalType: "address" },
      { type: "uint256", name: "tokenId", internalType: "uint256" },
      { type: "bytes", name: "data", internalType: "bytes" },
    ],
  },
  {
    type: "function",
    stateMutability: "nonpayable",
    outputs: [],
    name: "setApprovalForAll",
    inputs: [
      { type: "address", name: "operator", internalType: "address" },
      { type: "bool", name: "approved", internalType: "bool" },
    ],
  },
  {
    type: "function",
    stateMutability: "nonpayable",
    outputs: [],
    name: "setBaseUri",
    inputs: [
      { type: "uint256[]", name: "_tokenIds", internalType: "uint256[]" },
      { type: "string[]", name: "_baseUris", internalType: "string[]" },
    ],
  },
  {
    type: "function",
    stateMutability: "view",
    outputs: [{ type: "bool", name: "", internalType: "bool" }],
    name: "supportsInterface",
    inputs: [{ type: "bytes4", name: "interfaceId", internalType: "bytes4" }],
  },
  {
    type: "function",
    stateMutability: "view",
    outputs: [{ type: "string", name: "", internalType: "string" }],
    name: "symbol",
    inputs: [],
  },
  {
    type: "function",
    stateMutability: "view",
    outputs: [{ type: "uint256", name: "", internalType: "uint256" }],
    name: "tokenByIndex",
    inputs: [{ type: "uint256", name: "index", internalType: "uint256" }],
  },
  {
    type: "function",
    stateMutability: "view",
    outputs: [{ type: "uint256", name: "", internalType: "uint256" }],
    name: "tokenOfOwnerByIndex",
    inputs: [
      { type: "address", name: "owner", internalType: "address" },
      { type: "uint256", name: "index", internalType: "uint256" },
    ],
  },
  {
    type: "function",
    stateMutability: "view",
    outputs: [{ type: "string", name: "", internalType: "string" }],
    name: "tokenURI",
    inputs: [{ type: "uint256", name: "_tokenId", internalType: "uint256" }],
  },
  {
    type: "function",
    stateMutability: "view",
    outputs: [{ type: "uint256", name: "", internalType: "uint256" }],
    name: "totalSupply",
    inputs: [],
  },
  {
    type: "function",
    stateMutability: "nonpayable",
    outputs: [],
    name: "transferFrom",
    inputs: [
      { type: "address", name: "from", internalType: "address" },
      { type: "address", name: "to", internalType: "address" },
      { type: "uint256", name: "tokenId", internalType: "uint256" },
    ],
  },
  {
    type: "function",
    stateMutability: "nonpayable",
    outputs: [],
    name: "transferOwnership",
    inputs: [{ type: "address", name: "newOwner", internalType: "address" }],
  },
];



================================================
FILE: src/blockchain/NFT/mint.ts
================================================
import { abi, address } from "./abi";
import { address as Mine } from "../Mine/abi";
import { useContractWrite } from "wagmi";

export const useMint = () => {
  const { write, isSuccess, isLoading, isError } = useContractWrite({
    abi,
    address,
    functionName: "mint",
  });

  return {
    mint: write,
    minting: isLoading,
    minted: isSuccess,
  };
};



================================================
FILE: src/blockchain/NFT/revoke.ts
================================================
import { abi, address } from "./abi";
import { address as Mine } from "../Mine/abi";
import { Address, useContractWrite } from "wagmi";
import { toast } from "react-toastify";

export const useRevoke = (mine: string) => {
  const { write, isSuccess, isLoading, isError } = useContractWrite({
    abi,
    address,
    functionName: "setApprovalForAll",
    args: [mine, false],
  });

  return {
    revoke: write,
    revoking: isLoading,
    revoked: isSuccess,
    revokeError: isError,
  };
};



================================================
FILE: src/blockchain/NFT/setApprovalForAll.ts
================================================
import { abi, address } from "./abi";
import { address as Mine } from "../Mine/abi";
import { Address, useContractWrite } from "wagmi";
import { useState } from "react";
import { viem } from "~/server/api/services/viem.service";

export const useSetApprovalForAll = (mine: string) => {
  const { write, isSuccess, isLoading, isError } = useContractWrite({
    abi,
    address,
    functionName: "setApprovalForAll",
    args: [mine, true],
  });

  return {
    setApprovalForAll: write,
    approving: isLoading,
    approved: isSuccess,
    approvedError: isError,
  };
};

export const useApprovalForAllEvent = (owner: string, mineAddress: Address) => {
  const [approved, setApproved] = useState<boolean>(false);
  const [revoked, setRevoked] = useState<boolean>(false);

  viem.watchContractEvent({
    address: mineAddress,
    abi,
    eventName: "ApprovalForAll",
    onLogs: (log: any[]) => {
      if (log[0].args.approved == true && log[0].args.owner == owner) {
        setApproved(true);
      }
      if (log[0].args.approved == false && log[0].args.owner == owner) {
        setRevoked(true);
      }
    },
  });

  const resetApproved = () => {
    setApproved(false);
  };
  const resetRevoked = () => {
    setRevoked(false);
  };

  return {
    approvedEvent: approved,
    revokedEvent: revoked,
    resetApproved,
    resetRevoked,
  };
};



================================================
FILE: src/components/Home/BoxLeft.tsx
================================================
import Link from "next/link";
import TypingText from "~/components/Shared/Typepography/TypingText/Text";

const texts: string[] = ["NFT", "Mining", "Privilege"];

export default function BoxLeft() {
  return (
    <div className="order-1 col-span-12 flex flex-col justify-center gap-6  p-4 md:order-none md:col-span-4">
      <div>
        <div className="text-[50px] font-bold leading-[120%] text-white xl:text-[80px]">
          More Than Profession
        </div>
        <TypingText texts={texts} />
      </div>

      <p className="text-slate-300">
        the group of people who admired NFT technology and Crypto mining.
        Therefore the holders can join many of our activities
      </p>

      <Link
        href="/mine"
        className="btn btn-info hidden text-white hover:bg-opacity-80 md:flex"
      >
        Start Mining
      </Link>
    </div>
  );
}



================================================
FILE: src/components/Home/BoxRight.tsx
================================================
import { useEffect } from "react";
import { useStakedEvent } from "~/blockchain/Mine/stake";
import { useUnStakedEvent } from "~/blockchain/Mine/unstake";
import { api } from "~/utils/api";
import { address } from "~/blockchain/Mine/abi";
import GridLayout from "~/components/Shared/Layout/GridLayout";
import GridSpacer from "~/components/Shared/Layout/GridSpacer";
import StatCard1 from "~/components/Shared/Card/StatCard1";

import { motion } from "framer-motion";
import StatCard3 from "../Shared/Card/StatCard3";
import { MineInfo } from "~/interfaces/blockchain/Mine/MineData";

interface BoxRightProps {
  mineName: string;
  mineInfo: MineInfo;
}

export default function BoxRight({ mineName, mineInfo }: BoxRightProps) {
  const {
    data: currentBlockNumber,
    isLoading: loadingBlockNumber,
    refetch: refetchBlockNumber,
  } = api.blockchain.get.useQuery();

  // const {
  //   data: mineInfo,
  //   isLoading: loadingMineInfo,
  //   refetch: refetchMineInfo,
  // } = api.mine.getMineInfo.useQuery();

  // console.log("info: ", mineInfo);

  const {
    data: balance,
    isLoading: loadingBalance,
    refetch: refetchMineBalance,
  } = api.reward.balanceOf.useQuery({
    address,
  });

  // const { stakedEvent, resetStaked } = useStakedEvent(address as string);
  // const { unStakedEvent, resetUnStaked } = useUnStakedEvent(address as string);

  //update when staking or unstaking event occured
  // useEffect(() => {
  //   refetchMineBalance();
  //   // refetchMineInfo();
  // }, [stakedEvent, resetStaked, unStakedEvent, resetUnStaked]);

  const boxSlider = (delay: number) => {
    return {
      initial: { y: 20, opacity: 0 },
      animate: { y: 0, opacity: 1 },
      transition: {
        duration: 0.6,
        ease: "easeInOut",
        type: "spring",
        stiffness: 25,
        delay: delay,
      },
    };
  };

  return (
    <div className="col-span-12 my-2 flex flex-col justify-center md:col-span-7">
      <GridLayout>
        <GridSpacer />
        <motion.div {...boxSlider(0.4)} className="col-span-12 md:col-span-4">
          <StatCard1
            title={mineName ?? "#Unknown"}
            value={mineInfo?.isActive ? "Open" : "Close"}
            count={false}
          />
        </motion.div>
        <motion.div {...boxSlider(0.5)} className="col-span-12 md:col-span-6">
          <StatCard1
            title="APR"
            value={`${mineInfo?.apr.toFixed(2).toString()} %`}
            count={false}
          />
        </motion.div>
        <GridSpacer />
        <GridSpacer />
        <motion.div {...boxSlider(0.6)} className="col-span-12 md:col-span-6">
          <StatCard1
            title="Total Hash Power"
            value={mineInfo?.totalHashPower.toString()}
            count={true}
          />
        </motion.div>
        <motion.div {...boxSlider(0.7)} className="col-span-12 md:col-span-4">
          <StatCard1
            title="TotalMiner"
            value={mineInfo?.totolStaked.toString()}
            count={true}
          />
        </motion.div>
        <GridSpacer />
        <GridSpacer />
        <motion.div {...boxSlider(0.8)} className="col-span-12 md:col-span-10">
          <StatCard3 title="Mining Period">
            <div className="flex flex-col items-end  leading-tight">
              <div className="text-[36px] font-bold text-white">
                {`${
                  loadingBlockNumber
                    ? "N/A"
                    : Math.floor(
                        ((+mineInfo?.endBlock.toString() -
                          +currentBlockNumber!.toString()) *
                          5) /
                          86400,
                      ).toString() > "0"
                    ? Math.floor(
                        ((+mineInfo?.endBlock.toString() -
                          +currentBlockNumber!.toString()) *
                          5) /
                          86400,
                      ).toString()
                    : "0"
                }days`}
              </div>
              <div className="flex flex-col text-[12px] font-semibold leading-tight text-gray-200">
                <div>
                  {`from ~${mineInfo?.startTime} to ~${mineInfo?.endTime}`}
                </div>
                <div>{`from ~block ${mineInfo?.startBlock} to ~block ${mineInfo?.endBlock}`}</div>
              </div>
            </div>
          </StatCard3>
        </motion.div>
        <GridSpacer />
      </GridLayout>
    </div>
  );
}



================================================
FILE: src/components/Home/BoxRightV2.tsx
================================================
import Image from "next/image";

import { motion } from "framer-motion";

export default function BoxRightV2() {
  const rockUp = (delay: number, y: number) => {
    return {
      initial: { y: y },
      animate: { y: 0 },
      transition: {
        duration: 0.2,
        ease: "easeIn",
        type: "spring",
        stiffness: 10,
        delay: delay,
      },
    };
  };

  const DigUpAndFloating = (delay: number, y: number, lastY: number) => {
    return {
      initial: { y: y, opacity: 0 },
      animate: { y: [30, lastY], opacity: 1 },
      transition: {
        duration: 0.5,
        ease: "easeIn",
        type: "spring",
        stiffness: 10,
        delay: delay,
      },
    };
  };

  return (
    <div className="relative col-span-12 my-2 flex min-h-[50vh] flex-col items-center justify-center md:col-span-7">
      <motion.div
        {...DigUpAndFloating(0.1, 0, -50)}
        className="absolute bottom-[20%] right-[3%] -z-[3] hidden w-96 xl:block"
      >
        <Image
          src="/images/main-red.png"
          width={300}
          height={300}
          alt="rock1"
        />
      </motion.div>
      <motion.div
        {...DigUpAndFloating(0.3, 0, -50)}
        className="absolute bottom-[20%] left-[3%] -z-[3] hidden w-96 xl:block"
      >
        <Image
          src="/images/main-blue.png"
          width={300}
          height={300}
          alt="rock1"
        />
      </motion.div>
      <motion.div
        {...DigUpAndFloating(0.2, 0, -50)}
        className="absolute bottom-[30%] -z-[3] w-36 md:w-48 xl:w-96"
      >
        <Image
          src="/images/main-yellow.png"
          width={300}
          height={300}
          alt="rock1"
        />
      </motion.div>
      <motion.div {...rockUp(0.1, 20)} className="absolute bottom-0">
        <Image src="/images/rock2.png" width={400} height={400} alt="rock1" />
      </motion.div>
      <motion.div
        {...rockUp(0.2, 30)}
        className="absolute bottom-[0] left-[20%] -z-[1]"
      >
        <Image src="/images/rock2.png" width={400} height={400} alt="rock1" />
      </motion.div>
      <motion.div
        {...rockUp(0.15, 50)}
        className="absolute bottom-0 right-[20%]"
      >
        <Image src="/images/rock1.png" width={400} height={400} alt="rock1" />
      </motion.div>
      <motion.div
        {...rockUp(0.1, 40)}
        className="absolute bottom-0 left-[20%] -z-[1]"
      >
        <Image src="/images/rock1.png" width={400} height={400} alt="rock1" />
      </motion.div>
    </div>
  );
}



================================================
FILE: src/components/Mine/CardElement.tsx
================================================
import Link from "next/link";
import { useAccount } from "wagmi";
import Image from "next/image";

interface CardElementProps {
  name: string;
  apr: string;
  earned: string;
  liquidity: string;
  totalStaked: string;
  totalHash?: string;
  active: boolean;
  end: string;
  mineAddress: string;
  link: string;
  rewardToken: string;
  image: string;
}
export default function CardElement({
  name,
  apr,
  earned,
  liquidity,
  totalStaked,
  totalHash,
  active,
  end,
  mineAddress,
  link,
  rewardToken,
  image,
}: CardElementProps) {
  const { isConnected } = useAccount();

  return (
    <div className="card glass w-96 w-full text-white shadow-xl md:max-w-[380px]">
      <figure className="relative w-full overflow-hidden">
        <Image src={image} alt="mine" width={1000} height={1000} />
        <div className="absolute right-[5%] top-[5%] font-bold">
          {active ? (
            <div className="badge badge-primary text-green-400 ring ring-green-300">
              Active
            </div>
          ) : (
            <div className="badge badge-ghost text-gray-400">Ended</div>
          )}
        </div>
      </figure>
      <div className="card-body">
        <h2 className="card-title">{name}</h2>
        <div className="badge badge-info font-semibold text-white">
          {rewardToken}
        </div>
        <hr />
        <div className="card-content">
          <div className="grid grid-cols-2">
            <div>APR</div>
            <div className="flex justify-end">{apr}</div>
            <div>EARN</div>
            <div className="flex justify-end">{earned}</div>
            <div>Liquidity</div>
            <div className="flex justify-end">
              {+liquidity > 0 ? (
                liquidity
              ) : (
                <span className="badge badge-info text-white">Pending</span>
              )}
            </div>
            <div>Total Staked</div>
            <div className="flex justify-end">{totalStaked}</div>
            <div>End</div>
            <div className="flex justify-end">{end}</div>
          </div>
        </div>
        <div className="card-actions justify-end">
          {isConnected ? (
            <Link
              href={`/${link}?mine=${mineAddress}&title=${name}&isActive=${active}`}
              className="font-bold"
            >
              <span className="btn btn-info font-bold text-white">Enter</span>
            </Link>
          ) : null}
        </div>
      </div>
    </div>
  );
}



================================================
FILE: src/components/Mine/Table.tsx
================================================
import { useAccount } from "wagmi";
import TableElement from "./TableElement";
import { api } from "~/utils/api";
import CardElement from "./CardElement";
import Loading from "../Shared/Inidcators/Loading";

export default function Table() {
  const { address } = useAccount();

  const {
    data: allMines,
    isLoading: loadingAllMine,
    refetch: refetchAllMine,
  } = api.mine.getAllMinesInfo.useQuery({
    owner: address!,
  });

  const {
    data: currentBlockNumber,
    isLoading: loadingBlockNumber,
    refetch: refetchBlockNumber,
  } = api.blockchain.get.useQuery();

  return (
    <>
      {/* <div className="hidden w-full md:block">
        <table className="table-xl table">
          <tbody>
            {allMines == undefined ||
            allMines.length <= 0 ||
            loadingAllMine ||
            loadingBlockNumber ? (
              <Loading className="text-white" />
            ) : (
              <>
                {allMines.map((mine, index) => (
                  <TableElement
                    link={mine?.link}
                    mineAddress={mine.mine!}
                    key={index}
                    active={mine?.isActive!}
                    earned={mine?.pendingReward.toString()!}
                    name={mine?.name}
                    //@ts-ignore
                    apr={mine?.apr.toFixed(5).toString()!}
                    liquidity={mine?.balance!}
                    totalStaked={mine?.totolStaked.toString()}
                    end={`${
                      mine || loadingBlockNumber
                        ? Math.floor(
                            ((+mine?.endBlock.toString() -
                              +currentBlockNumber!.toString()) *
                              5) /
                              86400,
                          ).toString() > "0"
                          ? Math.floor(
                              ((+mine?.endBlock.toString() -
                                +currentBlockNumber!.toString()) *
                                5) /
                                86400,
                            ).toString()
                          : "0"
                        : null
                    }days`}
                  />
                ))}
              </>
            )}
          </tbody>
        </table>
      </div> */}
      <div className="grids-col-1 grid max-w-[1440px] gap-2 md:grid-cols-2 xl:grid-cols-3">
        {allMines == undefined ||
        allMines.length <= 0 ||
        loadingAllMine ||
        loadingBlockNumber ? (
          <Loading className="text-white" />
        ) : (
          <>
            {allMines.map((mine, index) => (
              <CardElement
                link={mine?.link}
                image={mine?.image}
                rewardToken={mine?.rewardToken}
                mineAddress={mine.mine!}
                key={index}
                active={mine?.isActive!}
                earned={mine?.pendingReward.toString()!}
                name={mine?.name}
                //@ts-ignore
                apr={mine?.apr.toFixed(5).toString()!}
                liquidity={mine?.balance!}
                totalStaked={mine?.totolStaked.toString()}
                end={`${
                  mine || loadingBlockNumber
                    ? Math.floor(
                        ((+mine?.endBlock.toString() -
                          +currentBlockNumber!.toString()) *
                          5) /
                          86400,
                      ).toString() > "0"
                      ? Math.floor(
                          ((+mine?.endBlock.toString() -
                            +currentBlockNumber!.toString()) *
                            5) /
                            86400,
                        ).toString()
                      : "0"
                    : null
                }days`}
              />
            ))}
          </>
        )}
      </div>
    </>
  );
}



================================================
FILE: src/components/Mine/TableElement.tsx
================================================
import Link from "next/link";
import { useAccount } from "wagmi";

interface TableElementProps {
  name: string;
  apr: string;
  earned: string;
  liquidity: string;
  totalStaked: string;
  totalHash?: string;
  active: boolean;
  end: string;
  mineAddress: string;
  link: string;
}
export default function TableElement({
  name,
  apr,
  earned,
  liquidity,
  totalStaked,
  totalHash,
  active,
  end,
  mineAddress,
  link,
}: TableElementProps) {
  const { isConnected } = useAccount();

  return (
    <tr
      className={`bg-white bg-opacity-20 ${
        active ? "cursor-pointer text-white" : "text-slate-500"
      }`}
    >
      <td>
        <div className="font-bold">
          {name}{" "}
          {active ? (
            <div className="badge badge-primary text-green-400">active</div>
          ) : null}
        </div>
      </td>
      <td>
        <div className="text-sm">Earned</div>
        <div className="font-bold text-info">
          {(+earned).toFixed(10).toString() ?? 0}
        </div>
      </td>
      <td>
        <div className="text-sm">APR</div>
        <div className="font-bold text-info">{apr}</div>
      </td>
      <td>
        <div className="text-sm">Liquidity</div>
        <div className="font-bold text-info">
          {+liquidity > 0 ? (
            liquidity
          ) : (
            <span className="badge badge-primary">Pending</span>
          )}
        </div>
      </td>
      <td>
        <div className="text-sm">Total Staked</div>
        <div className="font-bold text-info">{totalStaked}</div>
      </td>
      <td>
        <div className="text-sm">End In</div>
        <div className="font-bold text-info">{end}</div>
      </td>
      <td>
        {isConnected ? (
          <Link
            href={`/${link}?mine=${mineAddress}&title=${name}&isActive=${active}`}
            className="font-bold"
          >
            <span className="btn btn-info font-bold text-white">Enter</span>
          </Link>
        ) : null}
      </td>
    </tr>
  );
}



================================================
FILE: src/components/Privilege/Card.tsx
================================================
import Link from "next/link";

interface PrivilegeCardProps {
  hero: string;
  avatar: string;
  title: string;
  content: string;
  link: string;
}
export default function PrivilegeCard({
  hero,
  avatar,
  title,
  content,
  link,
}: PrivilegeCardProps) {
  return (
    <div className="card w-64 bg-base-100 shadow-xl">
      <figure className="h-36 overflow-hidden">
        <img src={hero} alt={title} />
      </figure>
      <div className="card-body">
        <h2 className="card-title">
          <img src={avatar} className="avatar-circle avatar w-12" />
          {title}
        </h2>
        <p className="max-h-[50px] overflow-scroll">{content}</p>
        <div className="card-actions justify-end">
          <Link href={link} className="btn btn-primary">
            Claim Now
          </Link>
        </div>
      </div>
    </div>
  );
}



================================================
FILE: src/components/Privilege/List.tsx
================================================
import FloatingButton from "../Shared/Button/FloatingButton";
import PrivilegeCard from "./Card";

export default function PrivilegeList() {
  return (
    <div>
      <div className="flex w-full px-10 py-10">
        <h1 className="font-bold text-white">Privilege</h1>
      </div>
      <div className="grid w-full grid-cols-1 justify-evenly gap-2 px-10 md:grid-cols-2 xl:grid-cols-4">
        <PrivilegeCard
          hero="/images/jibjibcoin.jpeg"
          title="JIBJIB Coin Airdrop"
          avatar="/images/jibjibcoin2.png"
          content="JIBJIB Coin Airdrop for digdragon holder
          claiming on JBC Chain"
          link="/privilege/jibjib?title=JIBJIB Coin Airdrop&content=JIBJIB Coin Airdrop for digdragon holder
          claiming on JBC Chain&avatar=/images/jibjibcoin2.png"
        />
      </div>
      <FloatingButton />
    </div>
  );
}



================================================
FILE: src/components/Shared/LoadingScreen.tsx
================================================
import BaseLayoutV2 from "./Layout/BaseLayoutV2";

export default function LoadingScreen() {
  return (
    <BaseLayoutV2>
      <div className="flex min-h-screen w-full items-center justify-center">
        <div className="loading loading-spinner text-white"></div>
      </div>
    </BaseLayoutV2>
  );
}



================================================
FILE: src/components/Shared/PleaseConnectWallet.tsx
================================================
import { ConnectButton } from "@rainbow-me/rainbowkit";
import BaseLayoutV2 from "./Layout/BaseLayoutV2";

export default function PleaseConnectWallet() {
  return (
    <BaseLayoutV2>
      <div className="flex min-h-screen w-full items-center justify-center">
        Please Connect Wallet
        <ConnectButton />
      </div>
    </BaseLayoutV2>
  );
}



================================================
FILE: src/components/Shared/Button/FloatingButton.tsx
================================================
import { ConnectButton } from "@rainbow-me/rainbowkit";
import Link from "next/link";
import { useRouter } from "next/router";
import { TiThMenu } from "react-icons/ti";
import { useAccount } from "wagmi";
export default function FloatingButton() {
  const { isConnected } = useAccount();
  const { pathname } = useRouter();
  return (
    <div className="fixed bottom-5 right-5 z-[20] sm:hidden">
      <div className="dropdown-end dropdown-top dropdown">
        <div
          tabIndex={0}
          role="button"
          className="btn btn-circle btn-info btn-lg"
        >
          <TiThMenu size={24} className="text-white" />
        </div>
        {isConnected ? (
          <ul
            tabIndex={0}
            className="menu dropdown-content rounded-box z-[1] w-52  bg-info p-2 text-center text-white shadow-xl"
          >
            <li>
              <Link
                className={`${
                  pathname == "/privilege" ? "text-info" : "text-white"
                } flex items-center gap-2 hover:text-info`}
                href="/privilege"
              >
                Privilege
              </Link>
            </li>
            <li>
              <Link href="/mine">Mine Zone</Link>
            </li>
          </ul>
        ) : (
          <ul
            className="w-42 menu dropdown-content rounded-box z-[1]  bg-info p-2 text-center text-white shadow-xl"
            tabIndex={0}
          >
            <li className="flex w-full items-center justify-center">
              <ConnectButton />
            </li>
          </ul>
        )}
      </div>
    </div>
  );
}



================================================
FILE: src/components/Shared/Card/StatCard1.tsx
================================================
import Loading from "../Inidcators/Loading";
import CountUp from "react-countup";

interface StateCard1Props {
  title: string;
  value: string;
  count: boolean;
}

export default function StatCard1({ title, value, count }: StateCard1Props) {
  return (
    <div className="stats relative w-full overflow-hidden rounded-md bg-base-200 bg-opacity-50 shadow backdrop-blur-sm">
      {/* <div className="absolute -right-3 -top-3  h-[50px] w-[50px] rounded-full bg-info blur-xl"></div> */}
      <div className="stat">
        <div className="stat-title text-xl font-semibold text-slate-900">
          {title}
        </div>
        <div className="stat-value text-white">
          {value == "N/A" ? (
            <Loading />
          ) : (
            <>
              {count ? (
                <CountUp
                  start={+value - +value * 0.5}
                  end={+value}
                  duration={2}
                />
              ) : (
                value
              )}
            </>
          )}
        </div>
      </div>
    </div>
  );
}



================================================
FILE: src/components/Shared/Card/StatCard2.tsx
================================================
import Loading from "../Inidcators/Loading";

interface StatCard2Props {
  title: string;
  content: string;
  subContent?: string;
}

export default function StatCard2({
  title,
  content,
  subContent,
}: StatCard2Props) {
  return (
    <div className="stats w-full rounded-md bg-base-200 bg-opacity-50 shadow backdrop-blur-sm">
      <div className="stat">
        <div className="stat-title text-xl font-semibold text-slate-900">
          {title}
        </div>
        <div className="stat-value text-right text-slate-900">
          {content == "N/A" ? <Loading /> : content}
        </div>
        <div className="text-right text-xl font-semibold text-slate-900">
          {subContent == "N/A" ? <Loading /> : subContent}
        </div>
      </div>
    </div>
  );
}



================================================
FILE: src/components/Shared/Card/StatCard3.tsx
================================================
import { ReactNode } from "react";
import Loading from "../Inidcators/Loading";

interface StatCard2Props {
  title: string;
  children: ReactNode;
  subContent?: string;
}

export default function StatCard3({
  title,
  children,
  subContent,
}: StatCard2Props) {
  return (
    <div className="stats w-full rounded-md bg-base-200 bg-opacity-50 shadow backdrop-blur-sm">
      <div className="stat">
        <div className="stat-title text-xl font-semibold text-slate-900">
          {title}
        </div>
        {children}
        <div className="text-right text-xl font-semibold text-slate-900">
          {subContent == "N/A" ? <Loading /> : subContent}
        </div>
      </div>
    </div>
  );
}



================================================
FILE: src/components/Shared/Card/StatCardOutline.tsx
================================================
import { useEffect, useRef } from "react";
import CountUp, { useCountUp } from "react-countup";

interface StatCardOutlineProps {
  title: string;
  value: string;
  count: boolean;
  decimal: boolean;
}

export default function StatCardOutline({
  title,
  value,
  count,
  decimal,
}: StatCardOutlineProps) {
  const countRef = useRef<HTMLDivElement>(null);
  const { update } = useCountUp({
    decimals: decimal ? 10 : 0,
    ref: countRef,
    start: +value - +value * 0.001,
    end: +value,
    duration: 3,
    onUpdate: () => {
      console.log("update");
    },
  });

  useEffect(() => {
    update(value);
  }, [value]);

  return (
    <div className="min-w-[200px] rounded-xl border-[1px] border-info p-2">
      <div className="font-bold text-white">{title}</div>
      <div className="text-info">
        {count ? (
          <div ref={countRef} />
        ) : (
          // <CountUp
          //   start={+value - +value * 0.0001}
          //   end={+value}
          //   decimals={10}
          //   duration={3}
          // />
          value
        )}
      </div>
    </div>
  );
}



================================================
FILE: src/components/Shared/Inidcators/Loading.tsx
================================================
import React from "react";

interface LoadingProps {
  className?: string;
}

const Loading = ({ className }: LoadingProps) => {
  return (
    <span className={`loading loading-infinity loading-lg ${className}`}></span>
  );
};

export default Loading;



================================================
FILE: src/components/Shared/Layout/BaseLayoutV2.tsx
================================================
import Head from "next/head";
import { ReactNode } from "react";
import { ToastContainer } from "react-toastify";
import "react-toastify/dist/ReactToastify.css";
import { useRouter } from "next/router";

export default function BaseLayoutV2({ children }: { children: ReactNode }) {
  const { pathname } = useRouter();
  return (
    <div className="relative z-[1] min-h-screen w-full overflow-auto bg-gradient-to-br from-black from-[40%] via-slate-900 via-[50%] to-black to-[60%]">
      <Head>
        <title>DigDragon NFT Official</title>
        <meta
          name="description"
          content="the group of people who admired NFT technology and Crypto mining. Therefore the holders can join many of our activities"
        />
        <meta property="og:title" content="DigDragon NFT Official" />
        <meta property="og:url" content="https://digdragonnft.com" />
        <meta property="og:image" content="/images/ournfthero.png" />
      </Head>
      <img
        className={`absolute bottom-0 right-0 z-[-1] ${
          pathname === "/" ? "hidden" : "block"
        }`}
        src="/images/hero1.png"
        alt="hero image"
      />
      {children}
      <ToastContainer />
    </div>
  );
}



================================================
FILE: src/components/Shared/Layout/GridCell.tsx
================================================
import { ReactNode } from "react";

interface GridCellProps {
  children: ReactNode;
  className?: string;
  span: number;
}

export default function GridCell({
  children,
  span,
  className = "",
}: GridCellProps) {
  return (
    <div className={`col-span-${span.toString()} ${className}`}>{children}</div>
  );
}



================================================
FILE: src/components/Shared/Layout/GridLayout.tsx
================================================
import { ReactNode } from "react";

interface GridLayoutProps {
  children: ReactNode;
  className?: string;
}

export default function GridLayout({ children, className }: GridLayoutProps) {
  return (
    <div className={`${className} grid grid-cols-12 gap-[16px] px-[16px]`}>
      {children}
    </div>
  );
}



================================================
FILE: src/components/Shared/Layout/GridSpacer.tsx
================================================
export default function GridSpacer({ span = 1 }: { span?: number }) {
  return <div className={`col-span-${span.toString()}`}></div>;
}



================================================
FILE: src/components/Shared/Nav/NavBarV2.tsx
================================================
import { ConnectButton } from "@rainbow-me/rainbowkit";
import Link from "next/link";
import { useRouter } from "next/router";
import { useAccount } from "wagmi";
import { FaWallet } from "react-icons/fa";
import { GiMineWagon } from "react-icons/gi";

import { motion } from "framer-motion";

export default function NavBarV2() {
  const { pathname } = useRouter();
  const { isConnected } = useAccount();

  return (
    <div className="navbar z-[20] bg-slate-500 bg-opacity-30 px-6">
      <div className="navbar-start">
        {/* <h2 className="font-semibold text-white">DigDragon NFT</h2> */}
        <motion.div
          initial={{ y: -100, opacity: 0 }}
          animate={{ y: 0, opacity: 1 }}
          transition={{ duration: 0.3, delay: 1, type: "spring", damping: 10 }}
        >
          <Link href="/">
            <img src="/images/logo.png" alt="logo" />
          </Link>
        </motion.div>
      </div>
      <div className="navbar-center"></div>
      <div className="navbar-end flex gap-6">
        {isConnected ? (
          <div className="hidden gap-2 sm:flex">
            <Link
              className={`font-bold ${
                pathname == "/privilege" ? "text-info" : "text-white"
              } flex items-center gap-2 hover:text-info`}
              href="/privilege"
            >
              <FaWallet
                size={22}
                className={`${pathname == "/privilege" ? "text-info" : null}`}
              />
              <span className="hidden sm:block">Privilege</span>
            </Link>
            <Link
              className={`font-bold ${
                pathname == "/mine" ? "text-info" : "text-white"
              } flex items-center gap-2 hover:text-info`}
              href="/mine"
            >
              <GiMineWagon
                size={24}
                className={`${pathname == "/mine" ? "text-info" : null}`}
              />
              <span className="hidden sm:block ">Mine Zone</span>
            </Link>
          </div>
        ) : null}
        <div className="block md:hidden">
          <ConnectButton
            accountStatus="avatar"
            chainStatus="name"
            showBalance={false}
          />
        </div>
        <div className="hidden md:block">
          <ConnectButton
            accountStatus="address"
            chainStatus="name"
            showBalance={false}
            label="Connect Wallet"
          />
        </div>
      </div>
    </div>
  );
}



================================================
FILE: src/components/Shared/Typepography/Address.tsx
================================================
import React from "react";
import { type Address } from "~/types/Address";

const Address = ({
  address,
  abbr = false,
}: {
  address: Address;
  abbr?: boolean;
}) => {
  return (
    <div>
      {abbr ? `${address.slice(0, 5)}...${address.slice(37)}` : address}
    </div>
  );
};

export default Address;



================================================
FILE: src/components/Shared/Typepography/SecondHeader.tsx
================================================
import React from "react";

const SecondHeader = ({
  text,
  color = "text-secondary",
}: {
  text: string;
  color?: string;
}) => {
  return (
    <h2 className={`${color} py-3 text-center text-2xl font-bold`}>{text}</h2>
  );
};

export default SecondHeader;



================================================
FILE: src/components/Shared/Typepography/RollingNumber/index.tsx
================================================
import { useEffect, useRef, useState } from "react";
import { motion } from "framer-motion";

interface RollingNumberProps {
  number: number;
}

function formatForDisplay(number: number = 0) {
  return parseFloat(Math.max(number, 0).toString())
    .toFixed(2)
    .split("")
    .reverse();
}

export default function RollingNumber({ number }: RollingNumberProps) {
  const numArray = formatForDisplay(number);
  return (
    <div className="relative m-auto flex h-full flex-row-reverse overflow-hidden bg-red-300 text-white">
      {numArray.map((num, index) =>
        num === "." ? (
          <DecimalColumn key={index} />
        ) : (
          <NumberColumn key={index} digit={num} />
        ),
      )}
    </div>
  );
}

function NumberColumn({ digit }: { digit: string }) {
  const [position, setPosition] = useState<number>(0);
  const columnContainer = useRef<HTMLDivElement>(null);
  const setColumnToNumber = (number: string) => {
    setPosition(columnContainer!.current!.clientHeight * parseInt(number));
  };

  useEffect(() => setColumnToNumber(digit), [digit]);

  return (
    <div className="relative w-[18px] bg-red-400" ref={columnContainer}>
      <motion.div
        animate={{ y: position }}
        className="absolute bottom-0 h-[1000%] bg-green-200"
      >
        {[9, 8, 7, 6, 5, 4, 3, 2, 1, 0].map((num) => (
          <div className="" key={num}>
            <span>{num}</span>
          </div>
        ))}
      </motion.div>
      {/* <span className="hidden">0</span> */}
    </div>
  );
}

function DecimalColumn() {
  //display . for the decimal position
  return (
    <div>
      <span>.</span>
    </div>
  );
}



================================================
FILE: src/components/Shared/Typepography/TypingText/Cursor.tsx
================================================
import { motion } from "framer-motion";

const variants = {
  blinking: {
    opacity: [0, 0, 1, 1],
    transition: {
      duration: 0.5,
      repeat: Infinity,
      repeatDelay: 0,
      ease: "linear",
      times: [0, 0.5, 0.5, 1],
    },
  },
};

export default function Cursor() {
  return (
    <motion.div
      variants={variants}
      animate="blinking"
      className="inline-block h-[50px] w-[3px] translate-y-1 bg-info"
    ></motion.div>
  );
}



================================================
FILE: src/components/Shared/Typepography/TypingText/Text.tsx
================================================
import { useEffect } from "react";
import Cursor from "./Cursor";
import { animate, motion, useMotionValue, useTransform } from "framer-motion";

interface TypingTextProps {
  texts: string[];
}

export default function TypingText({ texts }: TypingTextProps) {
  const textIndex = useMotionValue(0);
  const baseText = useTransform(textIndex, (latest) => texts[latest] || "");
  const count = useMotionValue(0);
  const rounded = useTransform(count, (latest) => Math.round(latest));
  const displayText = useTransform(rounded, (latest) =>
    baseText.get().slice(0, latest),
  );

  const updatedThisRound = useMotionValue(true);

  useEffect(() => {
    animate(count, 60, {
      type: "tween",
      duration: 4,
      ease: "easeIn",
      repeat: Infinity,
      repeatType: "reverse",
      repeatDelay: 2,
      onUpdate(latest) {
        if (updatedThisRound.get() === true && latest > 0) {
          updatedThisRound.set(false);
        } else if (updatedThisRound.get() === false && latest === 0) {
          if (textIndex.get() === texts.length - 1) {
            textIndex.set(0);
          } else {
            textIndex.set(textIndex.get() + 1);
          }

          updatedThisRound.set(true);
        }
      },
    });
  }, []);

  return (
    <span className="">
      <motion.span className="bg-gradient-to-br from-info to-purple-400 bg-clip-text text-[60px] font-semibold text-transparent">
        {displayText}
      </motion.span>
      <Cursor />
    </span>
  );
}



================================================
FILE: src/components/Wallet/Card/NftCard.tsx
================================================
import { TbPick } from "react-icons/tb";
import { LiaSlackHash } from "react-icons/lia";
import { PiSwordFill, PiShieldFill } from "react-icons/pi";
import { GiFluffyWing } from "react-icons/gi";
import { FaStar } from "react-icons/fa";
import { motion } from "framer-motion";
import { useEffect, useState } from "react";
import { useStake, useStakedEvent } from "~/blockchain/Mine/stake";
import { Address, useAccount } from "wagmi";
import { useUnStakedEvent, useUnstake } from "~/blockchain/Mine/unstake";

const variants = {
  hover: {
    x: 0,
  },
  initial: {
    x: 250,
  },
};

interface NFTCardProps {
  tokenId: string;
  name: string;
  image: string;
  video: string;
  hash: string;
  atk: string;
  def: string;
  spd: string;
  rarity: string;
  staked: boolean;
  canStake: boolean;
  mineAddress: string;
}

export default function NFTCard({
  tokenId,
  staked,
  name,
  image,
  video,
  hash,
  atk,
  def,
  spd,
  rarity,
  canStake,
  mineAddress,
}: NFTCardProps) {
  const [isHover, setIsHovered] = useState<boolean>(false);
  const { address } = useAccount();
  const [UnstakingLoading, setUnstakingLoading] = useState<boolean>(false);
  const [stakingLoading, setStakingLoading] = useState<boolean>(false);
  const {
    stake,
    staking,
    staked: stakedDone,
    stakingError,
  } = useStake(mineAddress);
  const { unstake, unstaking, unstaked, unstakingError } =
    useUnstake(mineAddress);
  const { stakedEvent, resetStaked } = useStakedEvent(
    address as string,
    mineAddress as Address,
  );
  const { unStakedEvent, resetUnStaked } = useUnStakedEvent(
    address as string,
    mineAddress as Address,
  );

  useEffect(() => {
    if (stakedEvent || unStakedEvent) {
      setStakingLoading(false);
      setUnstakingLoading(false);
      resetStaked();
      resetUnStaked();
    }

    if (stakingError || unstakingError) {
      setStakingLoading(false);
      setUnstakingLoading(false);
    }
  }, [stakedEvent, stakingError, unstakingError, stakedDone, unstaked]);

  const handleToMine = () => {
    setStakingLoading(true);
    const selectedTokenId = +tokenId!.toString();
    stake([selectedTokenId]);
  };
  const handleUnstake = () => {
    setUnstakingLoading(true);
    const selectedTokenId = +tokenId!.toString();
    unstake([selectedTokenId]);
  };

  function handleMouseEnter() {
    setIsHovered(true);
  }

  function handleMouseLeave() {
    setIsHovered(false);
  }

  return (
    <div
      onMouseEnter={handleMouseEnter}
      onMouseLeave={handleMouseLeave}
      className="relative z-[4] h-[225px] w-[225px] cursor-pointer overflow-hidden rounded-xl"
    >
      <motion.img
        variants={variants}
        animate={isHover ? { scale: 1.2, y: -5 } : []}
        transition={{ duration: 0.3 }}
        className="absolute left-0 top-0 object-contain"
        src={image}
        width={286}
        height={286}
      ></motion.img>
      {/* <source src={video} type="video/mp4" /> */}
      {/* </motion.img> */}
      {/* <motion.video
        variants={variants}
        animate={isHover ? { scale: 1.2, y: -5 } : []}
        transition={{ duration: 0.3 }}
        className="absolute left-0 top-0 object-contain"
        width={286}
        height={286}
        placeholder={image}
        loop
        autoPlay
      >
        <source src={video} type="video/mp4" />
      </motion.video> */}
      <div className="absolute flex h-[30px] w-full justify-between px-4 py-2 font-semibold text-white">
        <LiaSlackHash size={24} />
        <h1 className="text-info">{hash}</h1>
      </div>

      <div className="absolute right-[5%] top-[15%] z-[1] flex gap-1">
        <FaStar className="text-yellow-400" size={16} />
        {rarity == "rare" ||
        rarity == "super rare" ||
        rarity == "super special rare" ? (
          <FaStar className="text-yellow-400" size={16} />
        ) : null}
        {rarity == "super rare" || rarity == "super special rare" ? (
          <FaStar className="text-yellow-400" size={16} />
        ) : null}
        {rarity == "Super special rare" ? (
          <FaStar className="text-yellow-400" size={16} />
        ) : null}
      </div>

      <div className="absolute left-[3%] top-[20%] flex h-full w-[50px] flex-col text-white">
        <div className="flex gap-1 text-[12px] font-bold">
          <PiSwordFill size={16} /> {atk}
        </div>
        <div className="flex gap-1 text-[12px] font-bold">
          <PiShieldFill size={16} /> {def}
        </div>
        <div className="flex gap-1 text-[12px] font-bold">
          <GiFluffyWing size={16} /> {spd}
        </div>
      </div>

      <div className="absolute bottom-0 left-0 z-[1] flex h-[80px] w-full items-center justify-center bg-white bg-opacity-30 px-2 py-3 font-bold text-black backdrop-blur-sm">
        <motion.div
          animate={
            staked
              ? {
                  rotate: ["-10deg", "90deg", "90deg", "-10deg"],
                  backgroundColor: [
                    "#ffa300",
                    "#ffa300",
                    "#fff",
                    "#ffa300",
                    "#ffa300",
                  ],
                }
              : {
                  rotate: ["0deg"],
                  backgroundColor: [""],
                }
          }
          transition={{
            duration: 2,
            ease: "easeInOut",
            repeat: Infinity,
            repeatDelay: 1,
          }}
          className="absolute left-[40%] top-[-30%] flex h-[50px] w-[50px] translate-x-[-50%] items-center justify-center rounded-full bg-info"
        >
          <TbPick className="text-white" size={30} />
        </motion.div>
        <h1 className="mt-2 text-white">{name}</h1>
      </div>
      <motion.div
        variants={variants}
        transition={{ duration: 0.3, ease: "easeInOut" }}
        animate={
          isHover || stakingLoading || UnstakingLoading ? "hover" : "initial"
        }
        className="absolute left-0 top-0 z-[4] flex h-full w-full items-center justify-center gap-2 overflow-hidden bg-slate-800 bg-opacity-80"
      >
        {!staked ? (
          <button
            disabled={stakingLoading || !canStake}
            onClick={() => handleToMine()}
            className={`btn btn-info text-white hover:bg-white hover:text-info  disabled:text-white`}
          >
            {!stakingLoading ? "Stake" : "Staking.."}
          </button>
        ) : (
          <button
            disabled={UnstakingLoading || !canStake}
            onClick={() => handleUnstake()}
            className="disbled:text-slate-900 btn btn-info text-white hover:bg-white hover:text-info disabled:text-white"
          >
            {!UnstakingLoading ? "Unstake" : "Unstaking.."}
          </button>
        )}
        {/* <button className="btn bg-white text-info">Unstake</button> */}
      </motion.div>
    </div>
  );
}



================================================
FILE: src/interfaces/blockchain/Mine/MineData.ts
================================================
export interface MineData {
  mineNo: string;
  mineAddress: string;
  startBlock?: number;
  endBlock?: number;
  startTime?: string;
  endTime?: string;
  isActive: boolean;
  mineUrl?: string;
}

export interface MineInfo {
  mine: string;
  nft: string;
  reward: string;
  hashpower: string;
  feeCollector: string;
  fee: string;
  startBlock: bigint;
  endBlock: bigint;
  rewardPerBlock: bigint;
  accTokenPerShare: bigint;
  rewardsForWithdrawal: bigint;
  totolStaked: bigint;
  totalHashPower: bigint;
  isActive: boolean;
  apr: number;
  startTime: string;
  endTime: string;
  balance: bigint;
  pendingReward: bigint;
}



================================================
FILE: src/interfaces/blockchain/NFT/DigdragonMetadata.ts
================================================
export interface DigDragonMeta {
  tokenId?: string;
  name: string;
  description: string;
  image: string;
  attributes: [
    {
      trait_type: string;
      value: string;
    },
  ];
  hash_tags: string[];
  animation_url: string;
  media: string[];
}



================================================
FILE: src/interfaces/components/Shared/BaseLayoutProps.ts
================================================
import { ReactNode } from "react";

export interface BaseLayoutProps {
  children: ReactNode;
}



================================================
FILE: src/interfaces/components/Shared/Container/BaseContainerProps.ts
================================================
import { ReactNode } from "react";

export interface BaseContainerProps {
  children: ReactNode;
}



================================================
FILE: src/interfaces/components/Shared/Navbar/MenuItemProps.ts
================================================
export interface MenuItemProps {
  title: string;
  path: string;
}



================================================
FILE: src/interfaces/Wallet/MyNFTProps.ts
================================================
import { type DigDragonMeta } from "../blockchain/NFT/DigdragonMetadata";

export interface MyNFTProps {
  data: DigDragonMeta;
  isApprovedForAll: boolean;
}



================================================
FILE: src/interfaces/Wallet/MyNFTRarity.ts
================================================
export interface MyNFTRarity {
  text: string;
  color: string;
}



================================================
FILE: src/interfaces/Wallet/MyNFTStatProps.ts
================================================
import { type ReactNode } from "react";

export interface MyNFTStatProps {
  icon: ReactNode;
  title?: string | undefined;
  value?: string | undefined;
}



================================================
FILE: src/interfaces/Wallet/MyNFTStatusProp.ts
================================================
import { type ReactNode } from "react";

export interface MyNFTStatusProps {
  icon?: ReactNode;
  value?: string | undefined;
  title?: string | undefined;
}



================================================
FILE: src/pages/_app.tsx
================================================
import { type AppType } from "next/app";
import { api } from "~/utils/api";
import "~/styles/globals.css";
import "@rainbow-me/rainbowkit/styles.css";

import { WagmiConfig, configureChains, createConfig, mainnet } from "wagmi";
import { publicProvider } from "wagmi/providers/public";
import { bitkub, bitkub_testnet } from "~/blockchain/constants/bitkub";

import { getDefaultWallets, RainbowKitProvider } from "@rainbow-me/rainbowkit";
import { jbc } from "~/blockchain/constants/jbc";

const { chains, publicClient, webSocketPublicClient } = configureChains(
  [bitkub, jbc],
  [publicProvider()],
);

const { connectors } = getDefaultWallets({
  appName: "Dig Dragon NFT",
  projectId: process.env.NEXT_PUBLIC_PROJECT_ID as string,
  chains,
});

const config = createConfig({
  autoConnect: true,
  connectors,
  publicClient,
  webSocketPublicClient,
});

const MyApp: AppType = ({ Component, pageProps }) => {
  return (
    <WagmiConfig config={config}>
      <RainbowKitProvider modalSize="compact" chains={chains}>
        <Component {...pageProps} />
      </RainbowKitProvider>
    </WagmiConfig>
  );
};

export default api.withTRPC(MyApp);



================================================
FILE: src/pages/index.tsx
================================================
import React from "react";
import BoxLeft from "~/components/Home/BoxLeft";
import BoxRight from "~/components/Home/BoxRight";
import BaseLayoutV2 from "~/components/Shared/Layout/BaseLayoutV2";
import GridLayout from "~/components/Shared/Layout/GridLayout";
import GridSpacer from "~/components/Shared/Layout/GridSpacer";
import NavBarV2 from "~/components/Shared/Nav/NavBarV2";

import { useEffect, useState } from "react";
import FloatingButton from "~/components/Shared/Button/FloatingButton";
import LoadingScreen from "~/components/Shared/LoadingScreen";

import { motion } from "framer-motion";
import { useAccount } from "wagmi";
import { api } from "~/utils/api";
import Loading from "~/components/Shared/Inidcators/Loading";
import BoxRightV2 from "~/components/Home/BoxRightV2";

export default function Home() {
  const [ready, setReady] = useState<boolean>(false);
  const { address } = useAccount();
  const { data: allMines, isLoading: allMineLoading } =
    api.mine.getAllMinesInfo.useQuery({
      owner: address!,
    });

  useEffect(() => {
    setReady(true);
  }, [ready, setReady]);

  if (!ready) {
    return <LoadingScreen />;
  }

  return (
    <BaseLayoutV2>
      <NavBarV2 />
      <motion.div
        initial={{ y: 20, opacity: 0 }}
        animate={{ y: 0, opacity: 1 }}
        transition={{
          duration: 0.6,
          ease: "easeInOut",
          type: "spring",
          stiffness: 25,
        }}
        exit={{ opacity: 0 }}
        className="mt-10 flex h-[80vh] items-center justify-center"
      >
        <GridLayout className="h-full">
          <GridSpacer />
          <BoxLeft />
          <BoxRightV2 />
          <GridSpacer />
        </GridLayout>
      </motion.div>
      <FloatingButton />
    </BaseLayoutV2>
  );
}



================================================
FILE: src/pages/api/trpc/[trpc].ts
================================================
import { createNextApiHandler } from "@trpc/server/adapters/next";

import { env } from "~/env.mjs";
import { appRouter } from "~/server/api/root";
import { createTRPCContext } from "~/server/api/trpc";

// export API handler
export default createNextApiHandler({
  router: appRouter,
  createContext: createTRPCContext,
  onError:
    env.NODE_ENV === "development"
      ? ({ path, error }) => {
          console.error(
            `❌ tRPC failed on ${path ?? "<no-path>"}: ${error.message}`
          );
        }
      : undefined,
});



================================================
FILE: src/pages/dig-space/[[...index]].tsx
================================================
import Head from 'next/head'
import { NextStudio } from 'next-sanity/studio'
import { metadata } from 'next-sanity/studio/metadata'
import config from '../../../sanity.config'

export default function StudioPage() {
  return (
    <>
      <Head>
        {Object.entries(metadata).map(([key, value]) => (
          <meta key={key} name={key} content={value} />
        ))}
      </Head>
      <NextStudio config={config} />
    </>
  )
}


================================================
FILE: src/pages/mine/index.tsx
================================================
import React, { useEffect, useState } from "react";
import Table from "~/components/Mine/Table";
import BaseLayoutV2 from "~/components/Shared/Layout/BaseLayoutV2";
import FloatingButton from "~/components/Shared/Button/FloatingButton";
import NavBarV2 from "~/components/Shared/Nav/NavBarV2";
import LoadingScreen from "~/components/Shared/LoadingScreen";
import { useAccount } from "wagmi";
import { useRouter } from "next/router";

const Mine = () => {
  const { replace } = useRouter();
  const { isConnected } = useAccount();
  const [ready, setReady] = useState<boolean>(false);

  useEffect(() => {
    setReady(true);

    if (!isConnected) {
      replace("/");
    }
  }, [ready, setReady, isConnected]);

  if (!ready || !isConnected) {
    return <LoadingScreen />;
  }
  return (
    <BaseLayoutV2>
      <NavBarV2 />
      <div className="flex w-full px-10 py-10">
        <h1 className="font-bold text-white">Mine Zone</h1>
      </div>
      <div className="flex justify-center px-10">
        <Table />
      </div>
      <FloatingButton />
    </BaseLayoutV2>
  );
};

export default Mine;



================================================
FILE: src/pages/privilege/index.tsx
================================================
import { useRouter } from "next/router";
import { useEffect, useState } from "react";
import { useAccount } from "wagmi";
import PrivilegeList from "~/components/Privilege/List";
import FloatingButton from "~/components/Shared/Button/FloatingButton";
import BaseLayoutV2 from "~/components/Shared/Layout/BaseLayoutV2";
import LoadingScreen from "~/components/Shared/LoadingScreen";
import NavBarV2 from "~/components/Shared/Nav/NavBarV2";

export default function PrivilegePage() {
  const { replace } = useRouter();
  const { isConnected } = useAccount();
  const [ready, setReady] = useState<boolean>(false);

  useEffect(() => {
    if (!isConnected) {
      replace("/");
    }
    setReady(true);
  }, [ready, setReady, isConnected]);

  if (!ready || !isConnected) {
    return <LoadingScreen />;
  }

  return (
    <BaseLayoutV2>
      <NavBarV2 />
      {/* <PrivilegeList /> */}
      <div className="p-10 text-xl font-bold text-white">
        Under Maintainance
      </div>
      <FloatingButton />
    </BaseLayoutV2>
  );
}



================================================
FILE: src/pages/privilege/jibjib.tsx
================================================
import { useRouter } from "next/router";
import { useEffect, useState } from "react";
import { useAccount } from "wagmi";
import BaseLayoutV2 from "~/components/Shared/Layout/BaseLayoutV2";
import LoadingScreen from "~/components/Shared/LoadingScreen";
import NavBarV2 from "~/components/Shared/Nav/NavBarV2";
import { useSwitchNetwork, useChainId } from "wagmi";
import { api } from "~/utils/api";
import FloatingButton from "~/components/Shared/Button/FloatingButton";
import { toast } from "react-toastify";
import {
  useClaimWhitelist,
  useUpdateRewardEvent,
} from "~/blockchain/JBC/DistributorWhitelist/claim";
import { useClaimedEvent } from "~/blockchain/JBC/Distributor/claim";

export default function PrivilegePage() {
  const [ready, setReady] = useState<boolean>(false);
  const [claiming, setClaiming] = useState<boolean>(false);
  const [approving, setApproving] = useState<boolean>(false);

  const { switchNetwork } = useSwitchNetwork();
  const chainId = useChainId();

  const { replace, query } = useRouter();
  const { isConnected, address } = useAccount();
  const { claim } = useClaimWhitelist();

  const { data: approvable } = api.jbcWL.isApprovable.useQuery({
    address: address!,
  });

  const {
    mutate: updateReward,
    isSuccess: rewardUpdated,
    isError: rewardUpdatedError,
  } = api.jbcWL.updateReward.useMutation();
  const { data: claimable } = api.jbcWL.getClaimableOf.useQuery({
    address: address!,
  });

  const { updateRewardEvent, resetUpdateReward } = useUpdateRewardEvent(
    address!,
  );
  const { claimedEvent, resetClaimed } = useClaimedEvent(address!);

  const { data: tokenOfOwner } = api.nft.tokensOfOwner.useQuery({
    wallet: address!,
  });

  useEffect(() => {
    if (updateRewardEvent) {
      toast.success("Approving Successful !");
      setApproving(false);
      resetUpdateReward();
    }

    if (rewardUpdatedError) {
      toast.error("Approving Error, Try again");
      setApproving(false);
    }

    if (claimedEvent) {
      toast.success("Claiming Successful !");
      setClaiming(false);
      resetClaimed();
    }
  }, [rewardUpdated, rewardUpdatedError, updateRewardEvent, claimedEvent]);

  useEffect(() => {
    if (!isConnected) {
      replace("/");
    }
    setReady(true);
  }, [ready, setReady, isConnected, address]);

  if (!ready || !address) {
    return <LoadingScreen />;
  }

  const handleApproving = () => {
    setApproving(true);
    updateReward({ address: address! });
  };
  const handleClaiming = () => {
    setClaiming(true);
    claim();
  };

  return (
    <BaseLayoutV2>
      <NavBarV2 />
      {/* <div className="flex  w-full flex-col gap-2 px-10 py-10">
        <div className="flex items-center gap-2">
          <img src={query.avatar as string} className="w-12" />
          <h1 className="font-bold text-white">{query.title ?? "N/A"}</h1>
        </div>

        <div className="p-2 text-sm text-white">
          <p>{query.content}</p>
          <p>approve your Dig Dragon and Claim JIBJIB Coin</p>
        </div>
      </div>
      <div className="grid w-full grid-cols-1 place-items-center px-10 pb-4">
        <table className="table glass max-w-2xl">
          <thead className="text-white">
            <th>Image</th>
            <th>TokenId</th>
          </thead>
          <tbody>
            {tokenOfOwner ? (
              <>
                {tokenOfOwner?.map((token) => (
                  <tr>
                    <td>
                      <div className="avatar">
                        <div className="mask mask-squircle h-12 w-12">
                          <img src={token.image} alt={token.name} />
                        </div>
                      </div>
                    </td>
                    <td className="font-bold text-white">{token.name}</td>
                  </tr>
                ))}
              </>
            ) : (
              <td className="text-white">Empty</td>
            )}
          </tbody>
          {tokenOfOwner ? (
            <tfoot className="text-white">
              <tr>
                <td className="flex flex-col gap-2">
                  <div className="font-bold">
                    Claimable Amounts: {claimable}
                  </div>
                  {parseInt(claimable!) <= 0 ? (
                    <>
                      {approvable ? (
                        <button
                          disabled={approving}
                          onClick={() => handleApproving()}
                          className="btn btn-info text-white hover:bg-white hover:text-info disabled:text-white"
                        >
                          {approving ? "Approving.." : "Approve Digdragon"}
                        </button>
                      ) : (
                        <p>You are already claimed!</p>
                      )}
                    </>
                  ) : (
                    <>
                      {chainId !== 8899 ? (
                        <button
                          onClick={() => switchNetwork!(8899)}
                          className="btn btn-info text-white hover:bg-white hover:text-info"
                        >
                          Switch To JBC
                        </button>
                      ) : (
                        <button
                          disabled={claiming}
                          onClick={() => handleClaiming()}
                          className="btn btn-info text-white hover:bg-white hover:text-info disabled:text-white"
                        >
                          {claiming ? "Claiming.." : "Claim JIBJIB"}
                        </button>
                      )}
                    </>
                  )}
                </td>
                <td></td>
                <td></td>
              </tr>
            </tfoot>
          ) : null}
        </table>
      </div> */}
      <div>Empty</div>
      <FloatingButton />
    </BaseLayoutV2>
  );
}



================================================
FILE: src/pages/wallet/dig-x-moon.tsx
================================================
import React, { useEffect, useState } from "react";
import { Address, useAccount } from "wagmi";
import { useStake, useStakedEvent } from "~/blockchain/Mine/stake";
import { useUnStakedEvent, useUnstake } from "~/blockchain/Mine/unstake";
import { useRevoke } from "~/blockchain/NFT/revoke";
import {
  useApprovalForAllEvent,
  useSetApprovalForAll,
} from "~/blockchain/NFT/setApprovalForAll";
import Loading from "~/components/Shared/Inidcators/Loading";
import BaseLayoutV2 from "~/components/Shared/Layout/BaseLayoutV2";
import NavBarV2 from "~/components/Shared/Nav/NavBarV2";
import NFTCard from "~/components/Wallet/Card/NftCard";
import { api } from "~/utils/api";
import { useRouter } from "next/router";
import FloatingButton from "~/components/Shared/Button/FloatingButton";
import LoadingScreen from "~/components/Shared/LoadingScreen";
import StatCardOutline from "~/components/Shared/Card/StatCardOutline";
import { useClaim, useClaimedEvent } from "~/blockchain/JBC/Distributor/claim";
import { useChainId, useSwitchNetwork } from "wagmi";
import { parseEther } from "viem";

const WalletPage = () => {
  const { isConnected, address } = useAccount();
  const { replace, query } = useRouter();
  const { mine: mineAddress } = query;
  const chainId = useChainId();

  const [nft, setNfts] = useState<number[]>([]);
  const [approvedLoading, setApprovedLoading] = useState<boolean>(false);
  const [stakeLoading, setStakeLoading] = useState<boolean>(false);
  const [unstakeLoading, setUnstakeLoading] = useState<boolean>(false);

  //events
  const { approvedEvent, revokedEvent, resetApproved, resetRevoked } =
    useApprovalForAllEvent(address as string, mineAddress as Address);
  const { stakedEvent, resetStaked } = useStakedEvent(
    address as string,
    mineAddress as Address,
  );
  const { unStakedEvent, resetUnStaked } = useUnStakedEvent(
    address as string,
    mineAddress as Address,
  );

  const {
    data: mineInfo,
    isLoading: loadingMineInfo,
    refetch: refetchMineInfo,
  } = api.mine.getMineInfo.useQuery({ mine: mineAddress as string });

  const {
    data,
    isLoading: userInfoLoading,
    refetch: getUserInfo,
  } = api.mine.getUserInfo.useQuery({
    wallet: address as string,
    mineAddress: mineAddress as Address,
  });

  const {
    data: tokensOfOwner,
    isSuccess: gotTokenOfOwner,
    refetch: getTokenOfOwner,
  } = api.digxmoon.tokensOfOwner.useQuery({
    wallet: address as string,
  });

  const {
    data: balance,
    isLoading: loadingBalance,
    refetch: refetchMyBalance,
  } = api.jbc.balanceOf.useQuery({
    address: address as string,
  });

  const { data: stakedTokens, refetch: refetchStakedTokens } =
    api.mine.getStakedTokenOf.useQuery({
      wallet: address as string,
      mineAddress: mineAddress as Address,
    });

  const { data: isApprovedForAll, refetch: getIsApprovalForAll } =
    api.digxmoon.isApprovedForAll.useQuery({
      wallet: address as string,
      mineAddress: mineAddress as Address,
    });

  const { stake, staking, stakingError } = useStake(mineAddress as string);

  const { unstake, unstaking, unstakingError } = useUnstake(
    mineAddress as string,
  );

  const { revoke, revoking, revokeError } = useRevoke(mineAddress as string);

  const { setApprovalForAll, approving, approvedError } = useSetApprovalForAll(
    mineAddress as string,
  );

  //JBC
  const [pendingReward, setPendingReward] = useState<bigint>();
  const [claimingLoading, setClaiming] = useState<boolean>(false);
  const { claim, claiming, claimingError } = useClaim();
  const { claimedEvent, resetClaimed } = useClaimedEvent(address!);
  const { mutate: updateReward, isLoading: rewardUpdating } =
    api.jbc.updateReward.useMutation();
  const { data: claimable } = api.jbc.getClaimableOf.useQuery({
    address: address!,
  });
  const { data: canClaim } = api.jbc.isClaimable.useQuery({
    address: address!,
  });
  const { switchNetwork } = useSwitchNetwork();

  const handleApprovalForAll = () => {
    setApprovedLoading(true);
    if (isApprovedForAll) {
      setApprovedLoading(false);
      return;
    }

    setApprovalForAll();
  };

  const handleRevoke = () => {
    setApprovedLoading(true);
    if (!isApprovedForAll) {
      setApprovedLoading(false);
      return;
    }
    revoke();
  };

  const handleSendAll = () => {
    setStakeLoading(true);
    if (!isApprovedForAll) {
      setStakeLoading(false);
      return;
    }

    stake(nft);
  };

  const handleUnStakeAll = () => {
    setUnstakeLoading(true);
    if (data?.userInfo.stakedTokenIds.length! <= 0) {
      setUnstakeLoading(false);
      return;
    }
    const tokenIds =
      data?.userInfo.stakedTokenIds.map((tokenId) =>
        parseInt(tokenId.toString()),
      ) ?? [];

    if (tokenIds.length <= 0) return;
    setPendingReward(parseEther(data?.pendingReward!));
    unstake(tokenIds);
  };

  async function handleClaim() {
    setClaiming(true);
    if (!canClaim) {
      console.log("cannot claimed");
      setClaiming(false);
      return;
    }
    claim();
  }

  useEffect(() => {
    getIsApprovalForAll();
    getUserInfo();
    getTokenOfOwner();
    refetchStakedTokens();
    refetchMyBalance();
    setNfts(
      tokensOfOwner == undefined
        ? []
        : tokensOfOwner!.map((n) => +n.tokenId.toString()),
    );

    if (approvedEvent || approvedError) {
      setApprovedLoading(false);
      resetApproved();
    }

    if (revokedEvent || revokeError) {
      setApprovedLoading(false);
      resetRevoked();
    }

    if (stakedEvent || stakingError) {
      setStakeLoading(false);
      resetStaked();
    }

    if (unStakedEvent || unstakingError) {
      setUnstakeLoading(false);
      if (unStakedEvent) {
        console.log("updating pending reward : ", pendingReward);
        updateReward({ address: address!, pending: pendingReward! });
      }
      resetUnStaked();
    }

    if (claimedEvent || claimingError) {
      setClaiming(false);
      resetClaimed();
    }

    if (!isConnected) {
      replace("/");
    }
  }, [
    isApprovedForAll,
    approvedEvent,
    revokedEvent,
    stakedEvent,
    unStakedEvent,
    stakingError,
    unstakingError,
    approvedError,
    revokeError,
    isConnected,
    claimedEvent,
    claimingError,
  ]);

  const [ready, setReady] = useState<boolean>(false);

  useEffect(() => {
    setReady(true);
  }, [ready, setReady]);

  if (!ready || loadingBalance || userInfoLoading || !isConnected) {
    return <LoadingScreen />;
  }

  return (
    <BaseLayoutV2>
      <NavBarV2 />
      <div className="flex w-full flex-col px-10 py-10">
        <h1 className="font-bold text-white">My Collection</h1>
        <h2 className="text-sm font-semibold text-slate-400">@{mineAddress}</h2>
        <h2 className="text-sm font-semibold text-info">
          Mine on KUB, Claim on JBC
        </h2>
        <ul className="text-xm text-info">
          <li>
            1. When you unstake token from mine reward will be updated on JBC
          </li>
          <li>2. Click on Claim On JBC to claim your reward</li>
          <li className="font-semibold text-accent">
            notice: Do not forget to change to connect with JBC
          </li>
        </ul>
      </div>
      <div className="flex w-full flex-col items-center justify-between gap-2 bg-white bg-opacity-20 px-3 py-4 backdrop-blur-sm md:flex-row md:px-10 md:py-6">
        <div className="flex gap-2">
          {isApprovedForAll ? (
            <button
              className="btn text-red-800"
              disabled={revoking || staking || unstaking || approvedLoading}
              onClick={
                chainId == 8899
                  ? () => switchNetwork!(96)
                  : () => handleRevoke()
              }
            >
              {revoking || approvedLoading ? (
                <div className="flex items-center gap-2 text-white">
                  <Loading />
                  <span>Revoking..</span>
                </div>
              ) : (
                <span>Revoke</span>
              )}
            </button>
          ) : (
            <button
              className="btn btn-info text-white hover:bg-white hover:text-info"
              disabled={approving || approvedLoading}
              onClick={
                chainId == 8899
                  ? () => switchNetwork!(96)
                  : () => handleApprovalForAll()
              }
            >
              {approving || approvedLoading ? (
                <div className="flex items-center gap-2 text-white">
                  <Loading />
                  <span>Approving..</span>
                </div>
              ) : (
                <span>Approve</span>
              )}
            </button>
          )}
          <button
            className="btn btn-info text-white hover:bg-white hover:text-info"
            disabled={
              (!isApprovedForAll as boolean) ||
              staking ||
              stakeLoading ||
              unstaking ||
              revoking ||
              !mineInfo?.isActive ||
              tokensOfOwner == undefined
            }
            onClick={
              chainId == 8899 ? () => switchNetwork!(96) : () => handleSendAll()
            }
          >
            {staking || stakeLoading ? (
              <div className="flex items-center gap-2 text-white">
                <Loading />
                <span>Sending..</span>
              </div>
            ) : (
              <span>Send All</span>
            )}
          </button>
          <button
            className="btn btn-info text-white hover:bg-white hover:text-info"
            disabled={
              (data && data?.userInfo.stakedTokenIds.length <= 0) ||
              unstaking ||
              unstakeLoading
            }
            onClick={
              chainId == 8899
                ? () => switchNetwork!(96)
                : () => handleUnStakeAll()
            }
          >
            {unstaking || unstakeLoading ? (
              <div className="flex items-center gap-2 text-white">
                <Loading />
                <span>Unstaking</span>
              </div>
            ) : (
              <span>Unstake All</span>
            )}
          </button>
        </div>

        <div className="flex flex-col items-center gap-2 sm:flex-row">
          <div className="flex flex-col items-center justify-center gap-2 rounded-xl bg-info bg-opacity-30 p-2 sm:flex-row">
            <StatCardOutline
              title="Claimable on JBC"
              value={claimable?.toString()! ?? 0}
              count={true}
              decimal={true}
            />
            <button
              onClick={
                chainId == 8899
                  ? () => handleClaim()
                  : () => switchNetwork!(8899)
              }
              disabled={claimingLoading || +claimable! <= 0}
              className="btn  btn-info text-white hover:bg-white hover:text-info disabled:text-white"
            >
              {claimingLoading ? (
                "Claiming..."
              ) : (
                <>{chainId == 8899 ? "Claim On JBC" : "Switch Chain"}</>
              )}
            </button>
          </div>
          <StatCardOutline
            title="Earned"
            value={(+data?.pendingReward!).toFixed(10).toString()!}
            count={true}
            decimal={true}
          />
          <StatCardOutline
            title="Staked Hashpower"
            value={data?.userInfo?.stakedHashPowerAmount?.toString()!}
            count={true}
            decimal={false}
          />
          <StatCardOutline
            title="Your JIBJIB"
            value={balance?.toString()!}
            count={true}
            decimal={true}
          />
        </div>
      </div>

      <div className="max-w-[1440px] px-10 py-10">
        <div className="flex flex-wrap justify-center gap-2 md:justify-start">
          {[...(tokensOfOwner ?? []), ...(stakedTokens ?? [])]
            ?.sort((a, b) => +a.tokenId.toString() - +b.tokenId.toString())
            .map((n) => (
              <NFTCard
                mineAddress={mineAddress as string}
                canStake={mineInfo?.isActive!}
                tokenId={n.tokenId.toString()}
                staked={n.staked}
                key={n.tokenId.toString()}
                image={n.image}
                video={n.animation_url}
                name={n.name}
                hash={
                  n.attributes[0].value.toLowerCase() == "super rare"
                    ? (n.attributes[1].value * 20).toString()
                    : (n.attributes[1].value * 15).toString()
                }
                atk={"N/A"}
                def={"N/A"}
                spd={"N/A"}
                rarity={n.attributes[0].value.toLowerCase()}
              />
            ))
            .filter(onlyUnique)}
        </div>
      </div>
      <FloatingButton />
    </BaseLayoutV2>
  );
};

function onlyUnique(value: any, index: any, array: any[]) {
  return array.indexOf(value) === index;
}

export default WalletPage;



================================================
FILE: src/pages/wallet/index.tsx
================================================
import React, { useEffect, useState } from "react";
import { Address, useAccount, useBalance } from "wagmi";
import { useStake, useStakedEvent } from "~/blockchain/Mine/stake";
import { useUnStakedEvent, useUnstake } from "~/blockchain/Mine/unstake";
import { useRevoke } from "~/blockchain/NFT/revoke";
import {
  useApprovalForAllEvent,
  useSetApprovalForAll,
} from "~/blockchain/NFT/setApprovalForAll";
import Loading from "~/components/Shared/Inidcators/Loading";
import BaseLayoutV2 from "~/components/Shared/Layout/BaseLayoutV2";
import NavBarV2 from "~/components/Shared/Nav/NavBarV2";
import NFTCard from "~/components/Wallet/Card/NftCard";
import { api } from "~/utils/api";
import { useRouter } from "next/router";
import FloatingButton from "~/components/Shared/Button/FloatingButton";
import LoadingScreen from "~/components/Shared/LoadingScreen";
import StatCardOutline from "~/components/Shared/Card/StatCardOutline";
import Link from "next/link";

const WalletPage = () => {
  const { isConnected, address } = useAccount();
  const result = useBalance({ address });
  console.log(result);
  const { replace, query } = useRouter();
  const { mine: mineAddress, title, isActive } = query;

  const [nft, setNfts] = useState<number[]>([]);
  const [approvedLoading, setApprovedLoading] = useState<boolean>(false);
  const [stakeLoading, setStakeLoading] = useState<boolean>(false);
  const [unstakeLoading, setUnstakeLoading] = useState<boolean>(false);

  //events
  const { approvedEvent, revokedEvent, resetApproved, resetRevoked } =
    useApprovalForAllEvent(address as string, mineAddress as Address);
  const { stakedEvent, resetStaked } = useStakedEvent(
    address as string,
    mineAddress as Address,
  );
  const { unStakedEvent, resetUnStaked } = useUnStakedEvent(
    address as string,
    mineAddress as Address,
  );

  const {
    data: mineInfo,
    isLoading: loadingMineInfo,
    refetch: refetchMineInfo,
  } = api.mine.getMineInfo.useQuery({ mine: mineAddress as string });

  const {
    data,
    isLoading: userInfoLoading,
    refetch: getUserInfo,
  } = api.mine.getUserInfo.useQuery({
    wallet: address as string,
    mineAddress: mineAddress as Address,
  });

  const {
    data: tokensOfOwner,
    isSuccess: gotTokenOfOwner,
    refetch: getTokenOfOwner,
  } = api.nft.tokensOfOwner.useQuery({
    wallet: address as string,
  });

  const {
    data: balance,
    isLoading: loadingBalance,
    refetch: refetchMyBalance,
  } = api.reward.balanceOf.useQuery({
    address: address as string,
  });

  const { data: stakedTokens, refetch: refetchStakedTokens } =
    api.mine.getStakedTokenOf.useQuery({
      wallet: address as string,
      mineAddress: mineAddress as Address,
    });

  const { data: isApprovedForAll, refetch: getIsApprovalForAll } =
    api.nft.isApprovedForAll.useQuery({
      wallet: address as string,
      mineAddress: mineAddress as Address,
    });

  const { stake, staking, stakingError } = useStake(mineAddress as string);

  const { unstake, unstaking, unstakingError } = useUnstake(
    mineAddress as string,
  );

  const { revoke, revoking, revokeError } = useRevoke(mineAddress as string);

  const { setApprovalForAll, approving, approvedError } = useSetApprovalForAll(
    mineAddress as string,
  );

  const handleApprovalForAll = () => {
    setApprovedLoading(true);
    if (isApprovedForAll) {
      setApprovedLoading(false);
      return;
    }

    setApprovalForAll();
  };

  const handleRevoke = () => {
    setApprovedLoading(true);
    if (!isApprovedForAll) {
      setApprovedLoading(false);
      return;
    }
    revoke();
  };

  const handleSendAll = () => {
    setStakeLoading(true);
    if (!isApprovedForAll) {
      setStakeLoading(false);
      return;
    }

    stake(nft);
  };

  const handleUnStakeAll = () => {
    setUnstakeLoading(true);
    if (data?.userInfo.stakedTokenIds.length! <= 0) {
      setUnstakeLoading(false);
      return;
    }
    const tokenIds =
      data?.userInfo.stakedTokenIds.map((tokenId) =>
        parseInt(tokenId.toString()),
      ) ?? [];

    if (tokenIds.length <= 0) return;
    unstake(tokenIds);
  };

  useEffect(() => {
    getIsApprovalForAll();
    getUserInfo();
    getTokenOfOwner();
    refetchStakedTokens();
    refetchMyBalance();
    setNfts(
      tokensOfOwner === undefined || tokensOfOwner.length <= 0
        ? []
        : tokensOfOwner!.map((n) => +n.tokenId.toString()),
    );

    if (approvedEvent || approvedError) {
      setApprovedLoading(false);
      resetApproved();
    }

    if (revokedEvent || revokeError) {
      setApprovedLoading(false);
      resetRevoked();
    }

    if (stakedEvent || stakingError) {
      setStakeLoading(false);
      resetStaked();
    }

    if (unStakedEvent || unstakingError) {
      setUnstakeLoading(false);
      resetUnStaked();
    }

    if (!isConnected) {
      replace("/");
    }
  }, [
    isApprovedForAll,
    approvedEvent,
    revokedEvent,
    stakedEvent,
    unStakedEvent,
    stakingError,
    unstakingError,
    approvedError,
    revokeError,
    isConnected,
    tokensOfOwner,
  ]);

  const [ready, setReady] = useState<boolean>(false);

  useEffect(() => {
    setReady(true);
  }, [ready, setReady]);

  if (!ready || loadingBalance || userInfoLoading || !isConnected) {
    return <LoadingScreen />;
  }

  return (
    <BaseLayoutV2>
      <NavBarV2 />
      <div className="flex w-full flex-col px-10 py-10">
        <h1 className="flex items-center gap-3 font-bold text-white">
          Mine: {title}{" "}
          <div
            className={`badge ${
              isActive == "true"
                ? "badge-primary text-green-400"
                : "text-accent"
            }`}
          >
            {isActive == "true" ? "Active" : "Closed"}
          </div>
        </h1>
        <Link
          href={`https://www.bkcscan.com/address/${mineAddress}`}
          target="_blank"
          className="text-sm font-semibold text-slate-400"
        >
          @{mineAddress}
        </Link>
      </div>
      <div className="flex w-full flex-col items-center justify-between gap-2 bg-white bg-opacity-20 px-3 py-4 backdrop-blur-sm md:flex-row md:px-10 md:py-6">
        <div className="flex gap-2">
          {isApprovedForAll ? (
            <button
              className="btn text-red-800"
              disabled={revoking || staking || unstaking || approvedLoading}
              onClick={() => handleRevoke()}
            >
              {revoking || approvedLoading ? (
                <div className="flex items-center gap-2 text-white">
                  <Loading />
                  <span>Revoking..</span>
                </div>
              ) : (
                <span>Revoke</span>
              )}
            </button>
          ) : (
            <button
              className="btn btn-info text-white hover:bg-white hover:text-info"
              disabled={approving || approvedLoading}
              onClick={() => handleApprovalForAll()}
            >
              {approving || approvedLoading ? (
                <div className="flex items-center gap-2 text-white">
                  <Loading />
                  <span>Approving..</span>
                </div>
              ) : (
                <span>Approve</span>
              )}
            </button>
          )}
          <button
            className="btn btn-info text-white hover:bg-white hover:text-info"
            disabled={
              (!isApprovedForAll as boolean) ||
              staking ||
              stakeLoading ||
              unstaking ||
              revoking ||
              !mineInfo?.isActive ||
              tokensOfOwner == undefined
            }
            onClick={() => handleSendAll()}
          >
            {staking || stakeLoading ? (
              <div className="flex items-center gap-2 text-white">
                <Loading />
                <span>Sending..</span>
              </div>
            ) : (
              <span>Send All</span>
            )}
          </button>
          <button
            className="btn btn-info text-white hover:bg-white hover:text-info"
            disabled={
              (data && data?.userInfo.stakedTokenIds.length <= 0) ||
              unstaking ||
              unstakeLoading
            }
            onClick={() => handleUnStakeAll()}
          >
            {unstaking || unstakeLoading ? (
              <div className="flex items-center gap-2 text-white">
                <Loading />
                <span>Unstaking</span>
              </div>
            ) : (
              <span>Unstake All</span>
            )}
          </button>
        </div>

        <div className="flex flex-col items-center gap-2 sm:flex-row">
          <StatCardOutline
            title="Earned"
            value={(+data?.pendingReward!).toFixed(10).toString()!}
            count={true}
            decimal={true}
          />
          <StatCardOutline
            title="Staked Hashpower"
            value={data?.userInfo?.stakedHashPowerAmount?.toString()!}
            count={true}
            decimal={false}
          />
          <StatCardOutline
            title={mineInfo?.reward.includes("0x00") ? "Your KUB" : "Your kBTC"}
            value={
              mineInfo?.reward.includes("0x00")
                ? result.data?.formatted.toString()!
                : balance?.toString()!
            }
            count={true}
            decimal={true}
          />
        </div>
      </div>

      <div className="max-w-[1440px] px-10 py-10">
        <div className="flex flex-wrap justify-center gap-2 md:justify-start">
          {[...(tokensOfOwner ?? []), ...(stakedTokens ?? [])]
            ?.sort((a, b) => +a.tokenId.toString() - +b.tokenId.toString())
            .map((n) => (
              <NFTCard
                mineAddress={mineAddress as string}
                canStake={mineInfo?.isActive!}
                tokenId={n.tokenId.toString()}
                staked={n.staked}
                key={n.tokenId.toString()}
                image={n.image}
                video={n.animation_url}
                name={n.name}
                hash={n.attributes[5].value}
                atk={n.attributes[2].value}
                def={n.attributes[3].value}
                spd={n.attributes[4].value}
                rarity={n.attributes[0].value}
              />
            ))
            .filter(onlyUnique)}
        </div>
      </div>
      <FloatingButton />
    </BaseLayoutV2>
  );
};

function onlyUnique(value: any, index: any, array: any[]) {
  return array.indexOf(value) === index;
}

export default WalletPage;



================================================
FILE: src/pages/wallet/v2.tsx
================================================
export default function WalletV2() {
  return <div>404 Page not found</div>;
}
// import React, { useEffect, useState } from "react";
// import { useAccount } from "wagmi";
// import { useStake, useStakedEvent } from "~/blockchain/Mine/stake";
// import { useUnStakedEvent, useUnstake } from "~/blockchain/Mine/unstake";
// import { useRevoke } from "~/blockchain/NFT/revoke";
// import {
//   useApprovalForAllEvent,
//   useSetApprovalForAll,
// } from "~/blockchain/NFT/setApprovalForAll";
// import Loading from "~/components/Shared/Inidcators/Loading";
// import BaseLayoutV2 from "~/components/Shared/Layout/BaseLayoutV2";
// import NavBarV2 from "~/components/Shared/Nav/NavBarV2";
// import NFTCard from "~/components/Wallet/Card/NftCard";
// import { api } from "~/utils/api";
// import { useRouter } from "next/router";
// import FloatingButton from "~/components/Shared/Button/FloatingButton";
// import LoadingScreen from "~/components/Shared/LoadingScreen";
// import StatCardOutline from "~/components/Shared/Card/StatCardOutline";
// import Link from "next/link";

// const WalletPage = () => {
//   const { isConnected, address } = useAccount();
//   const { replace, query } = useRouter();

//   const { data: collections } = api.nft.getCollectionOf.useQuery({
//     address: address as string,
//   });

//   console.log(collections);

//   const [nft, setNfts] = useState<number[]>([]);
//   const [approvedLoading, setApprovedLoading] = useState<boolean>(false);
//   const [stakeLoading, setStakeLoading] = useState<boolean>(false);
//   const [unstakeLoading, setUnstakeLoading] = useState<boolean>(false);

//   //events
//   const { approvedEvent, revokedEvent, resetApproved, resetRevoked } =
//     useApprovalForAllEvent(address as string);
//   const { stakedEvent, resetStaked } = useStakedEvent(address as string);
//   const { unStakedEvent, resetUnStaked } = useUnStakedEvent(address as string);

//   const {
//     data: mineInfo,
//     isLoading: loadingMineInfo,
//     refetch: refetchMineInfo,
//   } = api.mine.getMineInfo.useQuery();

//   const {
//     data,
//     isLoading: userInfoLoading,
//     refetch: getUserInfo,
//   } = api.mine.getUserInfo.useQuery({
//     wallet: address as string,
//   });

//   const {
//     data: tokensOfOwner,
//     isSuccess: gotTokenOfOwner,
//     refetch: getTokenOfOwner,
//   } = api.nft.tokensOfOwner.useQuery({
//     wallet: address as string,
//   });

//   const {
//     data: balance,
//     isLoading: loadingBalance,
//     refetch: refetchMyBalance,
//   } = api.reward.balanceOf.useQuery({
//     address: address as string,
//   });

//   const { data: stakedTokens, refetch: refetchStakedTokens } =
//     api.mine.getStakedTokenOf.useQuery({
//       wallet: address as string,
//     });

//   const { data: isApprovedForAll, refetch: getIsApprovalForAll } =
//     api.nft.isApprovedForAll.useQuery({ wallet: address as string });

//   const { stake, staking, stakingError } = useStake();

//   const { unstake, unstaking, unstakingError } = useUnstake();

//   const { revoke, revoking, revokeError } = useRevoke();

//   const { setApprovalForAll, approving, approvedError } =
//     useSetApprovalForAll();

//   const handleApprovalForAll = () => {
//     setApprovedLoading(true);
//     if (isApprovedForAll) {
//       setApprovedLoading(false);
//       return;
//     }

//     setApprovalForAll();
//   };

//   const handleRevoke = () => {
//     setApprovedLoading(true);
//     if (!isApprovedForAll) {
//       setApprovedLoading(false);
//       return;
//     }
//     revoke();
//   };

//   const handleSendAll = () => {
//     setStakeLoading(true);
//     if (!isApprovedForAll) {
//       setStakeLoading(false);
//       return;
//     }

//     stake(nft);
//   };

//   const handleUnStakeAll = () => {
//     setUnstakeLoading(true);
//     if (data?.userInfo.stakedTokenIds.length! <= 0) {
//       setUnstakeLoading(false);
//       return;
//     }
//     const tokenIds =
//       data?.userInfo.stakedTokenIds.map((tokenId) =>
//         parseInt(tokenId.toString()),
//       ) ?? [];

//     if (tokenIds.length <= 0) return;
//     unstake(tokenIds);
//   };

//   useEffect(() => {
//     getIsApprovalForAll();
//     getUserInfo();
//     getTokenOfOwner();
//     refetchStakedTokens();
//     refetchMyBalance();
//     setNfts(
//       tokensOfOwner == undefined
//         ? []
//         : tokensOfOwner!.map((n) => +n.tokenId.toString()),
//     );

//     if (approvedEvent || approvedError) {
//       setApprovedLoading(false);
//       resetApproved();
//     }

//     if (revokedEvent || revokeError) {
//       setApprovedLoading(false);
//       resetRevoked();
//     }

//     if (stakedEvent || stakingError) {
//       setStakeLoading(false);
//       resetStaked();
//     }

//     if (unStakedEvent || unstakingError) {
//       setUnstakeLoading(false);
//       resetUnStaked();
//     }

//     if (!isConnected) {
//       replace("/");
//     }
//   }, [
//     isApprovedForAll,
//     approvedEvent,
//     revokedEvent,
//     stakedEvent,
//     unStakedEvent,
//     stakingError,
//     unstakingError,
//     approvedError,
//     revokeError,
//     isConnected,
//   ]);

//   const [ready, setReady] = useState<boolean>(false);

//   useEffect(() => {
//     setReady(true);
//   }, [ready, setReady]);

//   if (!ready || loadingBalance || userInfoLoading) {
//     return <LoadingScreen />;
//   }

//   return (
//     <BaseLayoutV2>
//       <NavBarV2 />
//       <div className="flex w-full flex-col px-10 py-10">
//         <h1 className="font-bold text-white">{query.collection}</h1>
//         <div className="text-slate-500">
//           {address?.slice(0, 6)}...{address?.slice(37)}
//         </div>
//       </div>
//       <div className="flex w-full flex-col items-center justify-between gap-2 bg-white bg-opacity-20 px-3 py-4 backdrop-blur-sm md:flex-row md:px-10 md:py-6">
//         <div className="flex flex-wrap gap-2">
//           {collections?.map((col) => (
//             <Link
//               className={`btn btn-info ${
//                 query.collection === col.collection ? "" : "btn-outline"
//               } text-white`}
//               key={col.btn}
//               href={`/wallet/v2?collection=${col.collection}`}
//             >
//               {col.btn}
//             </Link>
//           ))}
//         </div>
//         <div className="flex flex-col items-center gap-2 sm:flex-row">
//           <StatCardOutline
//             title="Earned"
//             value={(+data?.pendingReward!).toFixed(10).toString()}
//             count={true}
//           />
//           <StatCardOutline
//             title="Staked Hashpower"
//             value={data?.userInfo?.stakedHashPowerAmount?.toString()!}
//             count={false}
//           />
//           <StatCardOutline
//             title="Your kBTC"
//             value={balance?.toString()!}
//             count={false}
//           />
//         </div>
//       </div>

//       <div className="max-w-[1440px] px-10 py-10">
//         <div className="flex flex-wrap justify-center gap-2 md:justify-start">
//           {collections
//             ?.filter((col) => col.collection == query.collection)
//             .map((n) =>
//               n.metadata.map((m) => (
//                 <NFTCard
//                   canStake={mineInfo?.isActive!}
//                   tokenId={m.tokenId.toString()}
//                   staked={m.staked}
//                   key={m.tokenId.toString()}
//                   image={m.image}
//                   video={m.animation_url ?? m.image}
//                   name={m.name}
//                   hash={m.attributes[5].value}
//                   atk={m.attributes[2].value}
//                   def={m.attributes[3].value}
//                   spd={m.attributes[4].value}
//                   rarity={m.attributes[0].value}
//                 />
//               )),
//             )}
//         </div>
//       </div>
//       <FloatingButton />
//     </BaseLayoutV2>
//   );
// };

// function onlyUnique(value: any, index: any, array: any[]) {
//   return array.indexOf(value) === index;
// }

// {
//   /* .map((n) => (
//               <NFTCard
//                 canStake={mineInfo?.isActive!}
//                 tokenId={n.tokenId.toString()}
//                 staked={n.staked}
//                 key={n.tokenId.toString()}
//                 image={n.image}
//                 video={n.animation_url}
//                 name={n.name}
//                 hash={n.attributes[5].value}
//                 atk={n.attributes[2].value}
//                 def={n.attributes[3].value}
//                 spd={n.attributes[4].value}
//                 rarity={n.attributes[0].value}
//               />
//             ))
//             .filter(onlyUnique)} */
// }

// export default WalletPage;



================================================
FILE: src/server/db.ts
================================================
import { PrismaClient } from "@prisma/client";

import { env } from "~/env.mjs";

const globalForPrisma = globalThis as unknown as {
  prisma: PrismaClient | undefined;
};

export const db =
  globalForPrisma.prisma ??
  new PrismaClient({
    log:
      env.NODE_ENV === "development" ? ["query", "error", "warn"] : ["error"],
  });

if (env.NODE_ENV !== "production") globalForPrisma.prisma = db;



================================================
FILE: src/server/api/root.ts
================================================
import { createTRPCRouter } from "~/server/api/trpc";
import { nftRouter } from "./routers/nft";
import { mineRouter } from "./routers/mine";
import { blockChainRouter } from "./routers/blockchain";
import { rewardRouter } from "./routers/reward";
import { jbcRouter } from "./routers/jib-distributor";
import { digXMoonRouter } from "./routers/digxmoon";
import { jbcWLRouter } from "./routers/jib-distributor-whitelist";

/**
 * This is the primary router for your server.
 *
 * All routers added in /api/routers should be manually added here.
 */
export const appRouter = createTRPCRouter({
  mine: mineRouter,
  nft: nftRouter,
  blockchain: blockChainRouter,
  reward: rewardRouter,
  jbc: jbcRouter,
  jbcWL: jbcWLRouter,
  digxmoon: digXMoonRouter,
});

// export type definition of API
export type AppRouter = typeof appRouter;



================================================
FILE: src/server/api/trpc.ts
================================================
/**
 * YOU PROBABLY DON'T NEED TO EDIT THIS FILE, UNLESS:
 * 1. You want to modify request context (see Part 1).
 * 2. You want to create a new middleware or type of procedure (see Part 3).
 *
 * TL;DR - This is where all the tRPC server stuff is created and plugged in. The pieces you will
 * need to use are documented accordingly near the end.
 */
import { initTRPC } from "@trpc/server";
import { type CreateNextContextOptions } from "@trpc/server/adapters/next";
import superjson from "superjson";
import { ZodError } from "zod";

import { db } from "~/server/db";

/**
 * 1. CONTEXT
 *
 * This section defines the "contexts" that are available in the backend API.
 *
 * These allow you to access things when processing a request, like the database, the session, etc.
 */

type CreateContextOptions = Record<string, never>;

/**
 * This helper generates the "internals" for a tRPC context. If you need to use it, you can export
 * it from here.
 *
 * Examples of things you may need it for:
 * - testing, so we don't have to mock Next.js' req/res
 * - tRPC's `createSSGHelpers`, where we don't have req/res
 *
 * @see https://create.t3.gg/en/usage/trpc#-serverapitrpcts
 */
const createInnerTRPCContext = (_opts: CreateContextOptions) => {
  return {
    db,
  };
};

/**
 * This is the actual context you will use in your router. It will be used to process every request
 * that goes through your tRPC endpoint.
 *
 * @see https://trpc.io/docs/context
 */
export const createTRPCContext = (_opts: CreateNextContextOptions) => {
  return createInnerTRPCContext({});
};

/**
 * 2. INITIALIZATION
 *
 * This is where the tRPC API is initialized, connecting the context and transformer. We also parse
 * ZodErrors so that you get typesafety on the frontend if your procedure fails due to validation
 * errors on the backend.
 */

const t = initTRPC.context<typeof createTRPCContext>().create({
  transformer: superjson,
  errorFormatter({ shape, error }) {
    return {
      ...shape,
      data: {
        ...shape.data,
        zodError:
          error.cause instanceof ZodError ? error.cause.flatten() : null,
      },
    };
  },
});

/**
 * 3. ROUTER & PROCEDURE (THE IMPORTANT BIT)
 *
 * These are the pieces you use to build your tRPC API. You should import these a lot in the
 * "/src/server/api/routers" directory.
 */

/**
 * This is how you create new routers and sub-routers in your tRPC API.
 *
 * @see https://trpc.io/docs/router
 */
export const createTRPCRouter = t.router;

/**
 * Public (unauthenticated) procedure
 *
 * This is the base piece you use to build new queries and mutations on your tRPC API. It does not
 * guarantee that a user querying is authorized, but you can still access user session data if they
 * are logged in.
 */
export const publicProcedure = t.procedure;



================================================
FILE: src/server/api/routers/blockchain.ts
================================================
import { createTRPCRouter, publicProcedure } from "~/server/api/trpc";
import { getCurrentBlockNumber } from "../services/blockchain.service";

export const blockChainRouter = createTRPCRouter({
  get: publicProcedure.query(async () => {
    return await getCurrentBlockNumber();
  }),
});



================================================
FILE: src/server/api/routers/digxmoon.ts
================================================
import { z } from "zod";
import { createTRPCRouter, publicProcedure } from "~/server/api/trpc";
import {
  getBalanceOf,
  getCollectionOf,
  getTokensURIOf,
  isApprovedForAll,
} from "../services/digxmoon.service";
import { Address } from "viem";
import { address2 } from "~/blockchain/NFT/abi";

export const digXMoonRouter = createTRPCRouter({
  tokensOfOwner: publicProcedure
    .input(z.object({ wallet: z.string() }))
    .query(async ({ input }) => {
      return await getTokensURIOf(input.wallet as Address);
    }),
  isApprovedForAll: publicProcedure
    .input(z.object({ wallet: z.string(), mineAddress: z.string() }))
    .query(async ({ input }) => {
      return await isApprovedForAll(
        input.wallet as Address,
        input.mineAddress as Address,
      );
    }),
  balanceOf: publicProcedure
    .input(
      z.object({
        address: z.string(),
      }),
    )
    .query(async ({ input }) => {
      return await getBalanceOf(input.address as Address, address2);
    }),
  getCollectionOf: publicProcedure
    .input(
      z.object({
        address: z.string(),
      }),
    )
    .query(async ({ input }) => {
      return await getCollectionOf(input.address as Address);
    }),
});



================================================
FILE: src/server/api/routers/jib-distributor-whitelist.ts
================================================
import { createTRPCRouter, publicProcedure } from "~/server/api/trpc";
import {
  checkApproveable,
  // checkApproveable,
  getClaimableOf,
  getJibJibBalance,
  getPreClaimable,
  updateReward,
} from "../services/v2/jbc/jbc.distributor-whitelist.service";
import { z } from "zod";
import { Address } from "viem";

export const jbcWLRouter = createTRPCRouter({
  balanceOf: publicProcedure
    .input(z.object({ address: z.string() }))
    .query(async ({ input }) => {
      return await getJibJibBalance(input.address);
    }),
  updateReward: publicProcedure
    .input(z.object({ address: z.string() }))
    .mutation(async ({ input }) => {
      return await updateReward(input.address as Address);
    }),
  getPreClaimableOf: publicProcedure
    .input(
      z.object({
        address: z.string(),
      }),
    )
    .query(async ({ input }) => {
      return await getPreClaimable(input.address);
    }),
  getClaimableOf: publicProcedure
    .input(
      z.object({
        address: z.string(),
      }),
    )
    .query(async ({ input }) => {
      return await getClaimableOf(input.address);
    }),
  // isClaimable: publicProcedure
  //   .input(
  //     z.object({
  //       address: z.string(),
  //     }),
  //   )
  //   .query(async ({ input }) => {
  //     return await isClaimable(input.address);
  //   }),
  isApprovable: publicProcedure
    .input(
      z.object({
        address: z.string(),
      }),
    )
    .query(async ({ input }) => {
      return await checkApproveable(input.address);
    }),
});



================================================
FILE: src/server/api/routers/jib-distributor.ts
================================================
import { createTRPCRouter, publicProcedure } from "~/server/api/trpc";
import {
  getClaimableOf,
  getJibJibBalance,
  isClaimable,
  updateReward,
} from "../services/v2/jbc/jbc.distributor.service";
import { z } from "zod";
import { Address } from "viem";

export const jbcRouter = createTRPCRouter({
  balanceOf: publicProcedure
    .input(z.object({ address: z.string() }))
    .query(async ({ input }) => {
      return await getJibJibBalance(input.address);
    }),
  updateReward: publicProcedure
    .input(z.object({ address: z.string(), pending: z.bigint() }))
    .mutation(async ({ input }) => {
      return await updateReward(input.address as Address, input.pending);
    }),
  getClaimableOf: publicProcedure
    .input(
      z.object({
        address: z.string(),
      }),
    )
    .query(async ({ input }) => {
      return await getClaimableOf(input.address);
    }),
  isClaimable: publicProcedure
    .input(
      z.object({
        address: z.string(),
      }),
    )
    .query(async ({ input }) => {
      return await isClaimable(input.address);
    }),
});



================================================
FILE: src/server/api/routers/mine.ts
================================================
import { createTRPCRouter, publicProcedure } from "~/server/api/trpc";
import { getMineData } from "../services/mine.service";
import { z } from "zod";
import Address from "~/components/Shared/Typepography/Address";
import { scrapeViaBTC } from "../services/via-btc.service";
// import { address } from "~/blockchain/NFT/abi";
import {
  getAllMineInfo,
  getMineInfo,
  getUserInfo,
  getStakedTokenMetadataOf,
} from "../services/v2/mine-v2.service";
import { abi, address } from "~/blockchain/NFT/abi";
import {
  abi as abi2,
  address4,
  address5,
  address6,
  address7,
  address8,
} from "~/blockchain/Mine/abi2";

import {
  abi as abi3,
  address1,
  address2,
  address3,
  address9,
  address10,
  address11,
  address12,
  address13,
  address14,
  address15,
  address16,
  address17,
} from "~/blockchain/Mine/abi3";

const mines = [
  {
    abi: abi3,
    address: address1,
  },
  {
    abi: abi3,
    address: address2,
  },
  {
    abi: abi2,
    address: address4,
  },
  {
    abi: abi2,
    address: address5,
  },
  {
    abi: abi2,
    address: address6,
  },
  {
    abi: abi2,
    address: address7,
  },
  {
    abi: abi2,
    address: address8,
  },
  {
    abi: abi3,
    address: address9,
  },
  {
    abi: abi3,
    address: address10,
  },
  {
    abi: abi3,
    address: address11,
  },
  {
    abi: abi3,
    address: address12,
  },
  {
    abi: abi3,
    address: address13,
  },
  {
    abi: abi3,
    address: address14,
  },
  {
    abi: abi3,
    address: address15,
  },
  {
    abi: abi3,
    address: address16,
  },
  {
    abi: abi3,
    address: address17,
  },
  {
    abi: abi3,
    address: address3,
  },
];

export const mineRouter = createTRPCRouter({
  getAll: publicProcedure.query(async () => {
    return await getMineData();
  }),
  getUserInfo: publicProcedure
    .input(
      z.object({
        wallet: z.string(),
        mineAddress: z.string(),
      }),
    )
    .query(async ({ ctx, input }) => {
      return await getUserInfo(
        input.wallet as `0x${string}`,
        input.mineAddress as Address,
      );
    }),
  getMineInfo: publicProcedure
    .input(
      z.object({
        mine: z.string(),
      }),
    )
    .query(async ({ input }) => {
      const selected = mines.filter((mine) => mine.address == input.mine);
      return await getMineInfo(
        selected[0]?.abi,
        selected[0]?.address as Address,
      );
    }),

  getAllMinesInfo: publicProcedure
    .input(
      z.object({
        owner: z.string().optional(),
      }),
    )
    .query(async ({ input }) => {
      return await getAllMineInfo(input.owner as Address);
    }),
  getStakedTokenOf: publicProcedure
    .input(
      z.object({
        wallet: z.string(),
        mineAddress: z.string(),
      }),
    )
    .query(async ({ input }) => {
      return await getStakedTokenMetadataOf(
        input.wallet as Address,
        address,
        input.mineAddress as Address,
      );
    }),
  getRigInfo: publicProcedure.query(async () => {
    return await scrapeViaBTC();
  }),
});



================================================
FILE: src/server/api/routers/nft.ts
================================================
import { z } from "zod";
import { createTRPCRouter, publicProcedure } from "~/server/api/trpc";
import {
  getBalanceOf,
  getCollectionOf,
  getTokensURIOf,
  isApprovedForAll,
} from "../services/nft.service";
import { Address } from "viem";
import { address } from "~/blockchain/NFT/abi";

export const nftRouter = createTRPCRouter({
  tokensOfOwner: publicProcedure
    .input(z.object({ wallet: z.string() }))
    .query(async ({ input }) => {
      return await getTokensURIOf(input.wallet as Address);
    }),
  isApprovedForAll: publicProcedure
    .input(z.object({ wallet: z.string(), mineAddress: z.string() }))
    .query(async ({ input }) => {
      return await isApprovedForAll(
        input.wallet as Address,
        input.mineAddress as Address,
      );
    }),
  balanceOf: publicProcedure
    .input(
      z.object({
        address: z.string(),
      }),
    )
    .query(async ({ input }) => {
      return await getBalanceOf(input.address as Address, address);
    }),
  getCollectionOf: publicProcedure
    .input(
      z.object({
        address: z.string(),
      }),
    )
    .query(async ({ input }) => {
      return await getCollectionOf(input.address as Address);
    }),
});



================================================
FILE: src/server/api/routers/reward.ts
================================================
import { createTRPCRouter, publicProcedure } from "~/server/api/trpc";
import { getBalanceOf } from "../services/reward.service";
import { z } from "zod";
import { Address } from "viem";

export const rewardRouter = createTRPCRouter({
  balanceOf: publicProcedure
    .input(
      z.object({
        address: z.string(),
      }),
    )
    .query(async ({ input }) => {
      return await getBalanceOf(input.address as Address);
    }),
});



================================================
FILE: src/server/api/services/blockchain.service.ts
================================================
import { viem } from "./viem.service";

export const getCurrentBlockNumber = async () => {
  const blocknumber = await viem.getBlockNumber();
  return blocknumber;
};



================================================
FILE: src/server/api/services/digxmoon.service.ts
================================================
import { Address } from "viem";
import { abi, address2 } from "~/blockchain/NFT/abi";
import axios from "axios";
import { viem } from "./viem.service";
import { getCollections } from "../../../../sanity/lib/nft";

export const extractTokensMetadata = async (
  tokens: { uri: string; tokenId: bigint }[],
) => {
  const responses = await Promise.all(
    tokens.map(async (token) => {
      const res = await axios.get(token.uri);
      return {
        tokenId: token.tokenId,
        ...res.data,
      };
    }),
  );

  return responses;
};

export const getTokenURI = async (tokens: bigint[], nftAddress: Address) => {
  if (!nftAddress) return;
  const uris = (await Promise.all(
    tokens.map(async (token) => {
      const uri = await viem.readContract({
        abi,
        address: nftAddress,
        functionName: "tokenURI",
        args: [token],
      });
      return {
        tokenId: token,
        uri,
      };
    }),
  )) as { tokenId: bigint; uri: string }[];

  // console.log(uris);

  if (uris.length > 0) {
    const meta = await extractTokensMetadata(uris);
    return meta;
  }
};

export const getTokensURIOf = async (owner: Address) => {
  try {
    const tokens = await getTokensOfOwner(owner, address2);
    const tokenUris = await getTokenURI(tokens, address2);
    const unstakeUris = tokenUris?.map((uri) => ({ ...uri, staked: false }));

    return unstakeUris;
  } catch (error) {
    console.log(error);
    return [];
  }
};

export const getTokensOfOwner = async (owner: Address, nftAddress: Address) => {
  try {
    const balance = (await getBalanceOf(owner, nftAddress)) as bigint;
    let tokens = new Array(balance);

    if (tokens.toString() == "0") {
      return [];
    }

    for (let i = 0; i < balance; i++) {
      tokens[i] = (await viem.readContract({
        abi,
        address: nftAddress,
        functionName: "tokenOfOwnerByIndex",
        args: [owner, i],
      })) as bigint;
    }

    // console.log("tokens: ", tokens);

    return tokens;
  } catch (error) {
    console.log(error);
    return [];
  }
};

export const getBalanceOf = async (owner: Address, nftAddress: Address) => {
  const balance = await viem.readContract({
    abi,
    address: nftAddress,
    functionName: "balanceOf",
    args: [owner],
  });

  // console.log("balance: ", balance);
  return balance;
};

export const isApprovedForAll = async (
  owner: Address,
  mineAddress: Address,
) => {
  const result = await viem.readContract({
    abi,
    address: address2,
    functionName: "isApprovedForAll",
    args: [owner, mineAddress],
  });

  return result;
};

export const totalSupply = async (nftAddress: Address) => {
  const result = await viem.readContract({
    abi,
    address: nftAddress,
    functionName: "totalSupply",
  });

  return result;
};

export const getCollectionOf = async (owner: Address) => {
  try {
    const collections = await getCollections();
    const data = await Promise.all(
      collections.map(async (col) => {
        const balance = (await getBalanceOf(owner, col.address)) as bigint;
        const supply = await totalSupply(col.address);
        if (balance > 0) {
          const tokens = await getTokensOfOwner(owner, col.address);
          const metadata = await getTokenURI(tokens, col.address);

          return {
            collection: col.collectionName,
            btn: col.button,
            slug: col.slug,
            balance,
            totalSupply: supply,
            metadata: metadata!,
          };
        }

        return {
          collection: col.collectionName,
          btn: col.button,
          slug: col.slug,
          balance,
          totalSupply: supply,
          metadata: [],
        };
      }),
    );

    return data;
  } catch (error) {
    console.log(error);
  }
};



================================================
FILE: src/server/api/services/mine.service.ts
================================================
import { groq } from "next-sanity";
import { client } from "../../../../sanity/lib/client";
import { viem } from "./viem.service";
import { abi, address } from "~/blockchain/Mine/abi";
import { address as NFT } from "~/blockchain/NFT/abi";
import { MineType } from "sanity/schema/Mine";
import { Address, formatEther, formatUnits } from "viem";
import { contractAPRCalculator } from "../utils/contractAPR";
import { getTokenURI, getTokensURIOf } from "./nft.service";
import { calculateRewardTimeParameters } from "../utils/RewardCalculation";

export const getMineData = async () => {
  try {
    const query = groq`*[_type == "minedata"]`;
    const data = await client.fetch(query);
    return data;
  } catch (error) {
    // console.log(error);
    return [];
  }
};

export const getActiveMineData = async () => {
  try {
    const query = groq`*[_type == "minedata" && isActive == true]`;
    const data = await client.fetch<typeof MineType>(query);
    return data;
  } catch (error) {
    // console.log(error);
    return [];
  }
};

export const getUserInfo = async (wallet: Address) => {
  try {
    const userInfo = (await viem.readContract({
      abi,
      //@ts-ignore
      address: address,
      // address: mine[0].mineAddress,
      functionName: "getUserInfo",
      args: [wallet],
    })) as {
      stakedTokenIds: bigint[];
      stakedHashPowerAmount: bigint;
      lastIn: bigint;
      lastOut: bigint;
    };
    //@ts-ignore
    // const pendingReward = await getPendingReward(wallet, mine[0].mineAddress);
    const pendingReward = await getPendingReward(wallet, address);

    // console.log({
    //   userInfo: {
    //     //@ts-ignore
    //     stakedTokenIds: userInfo.stakedTokenIds,
    //     //@ts-ignore
    //     stakedHashPowerAmount: userInfo.stakedHashPowerAmount,
    //     lastIn: userInfo.lastIn,
    //     lastOut: userInfo.lastOut,
    //   },
    //   pendingReward: formatUnits(pendingReward[1], 18),
    // });
    return {
      userInfo: {
        //@ts-ignore
        stakedTokenIds: userInfo.stakedTokenIds,
        //@ts-ignore
        stakedHashPowerAmount: userInfo.stakedHashPowerAmount,
        lastIn: userInfo.lastIn.toString(),
        lastOut: userInfo.lastOut.toString(),
      },
      pendingReward: formatUnits(pendingReward[1], 18),
    };
  } catch (error) {
    console.log(error);
  }
};

export const getPendingReward = async (wallet: Address, mine: Address) => {
  try {
    const pendingReward = (await viem.readContract({
      address: mine,
      abi,
      functionName: "pendingReward",
      args: [wallet],
    })) as [string, bigint];
    return pendingReward;
  } catch (error) {
    // console.log(error);
    return [];
  }
};

export const getMineInfo = async () => {
  try {
    const info = (await viem.readContract({
      address,
      abi,
      functionName: "getMineInfo",
    })) as any;

    const currentBlock = await viem.getBlockNumber();

    const parsedData = {
      nft: info.digdragon ?? "0x00",
      reward: info.reward ?? "0x00",
      hashpower: info.hashStorage ?? "0x00",
      feeCollector: info.feeCollector ?? "0x00",
      fee: info.fee ?? "0x00",
      startBlock: info.startBlock ?? 0,
      endBlock: info.rewardEndBlock ?? 0,
      rewardPerBlock: info.rewardPerBlock ?? 0,
      accTokenPerShare: info.accTokenPerShare ?? 0,
      rewardsForWithdrawal: info.rewardsForWithdrawal ?? 0,
      totolStaked: info.totalStakedTokens ?? 0,
      totalHashPower: info.totalHashPower ?? 0,
      isActive:
        currentBlock > info.startBlock && info.rewardEndBlock > currentBlock,
      // isActive: true,
    };

    const apr = contractAPRCalculator(
      parsedData.rewardPerBlock,
      parsedData.totalHashPower,
      parsedData.accTokenPerShare,
    );

    const { startTime, endTime } = await calculateRewardTimeParameters(
      parsedData.startBlock,
      parsedData.endBlock,
    );

    return { ...parsedData, apr, startTime, endTime };
  } catch (error) {
    console.log(error);
    return null;
  }
};

export const getStakedTokenMetadataOf = async (
  wallet: string,
  nftAddress: string,
) => {
  try {
    const user = await getUserInfo(wallet as Address);

    if (!user) {
      console.log("user not found");
      return [];
    }

    const stakedTokenIds = user.userInfo.stakedTokenIds as bigint[];
    const tokenUris = await getTokenURI(stakedTokenIds, nftAddress as Address);

    if (!tokenUris) {
      return [];
    }

    const stakedUris = tokenUris.map((uri) => ({ ...uri, staked: true }));

    return stakedUris;
  } catch (error) {
    console.log("getStakedTokenMetadataOf", error);
    return [];
  }
};



================================================
FILE: src/server/api/services/nft.service.ts
================================================
import { Address } from "viem";
import { abi, address } from "~/blockchain/NFT/abi";
import axios from "axios";
import { viem } from "./viem.service";
import { getCollections } from "../../../../sanity/lib/nft";

export const extractTokensMetadata = async (
  tokens: { uri: string; tokenId: bigint }[],
) => {
  const responses = await Promise.all(
    tokens.map(async (token) => {
      const res = await axios.get(token.uri);
      return {
        tokenId: token.tokenId,
        ...res.data,
      };
    }),
  );

  return responses;
};

export const getTokenURI = async (tokens: bigint[], nftAddress: Address) => {
  if (!nftAddress) return;
  const uris = (await Promise.all(
    tokens.map(async (token) => {
      const uri = await viem.readContract({
        abi,
        address: nftAddress,
        functionName: "tokenURI",
        args: [token],
      });
      return {
        tokenId: token,
        uri,
      };
    }),
  )) as { tokenId: bigint; uri: string }[];

  // console.log(uris);

  if (uris.length > 0) {
    const meta = await extractTokensMetadata(uris);
    return meta;
  }
};

export const getTokensURIOf = async (owner: Address) => {
  try {
    const tokens = await getTokensOfOwner(owner, address);
    const tokenUris = await getTokenURI(tokens, address);
    const unstakeUris = tokenUris?.map((uri) => ({ ...uri, staked: false }));

    return unstakeUris;
  } catch (error) {
    console.log(error);
    return [];
  }
};

export const getTokensOfOwner = async (owner: Address, nftAddress: Address) => {
  try {
    const balance = (await getBalanceOf(owner, nftAddress)) as bigint;
    let tokens = new Array(balance);

    if (tokens.toString() == "0") {
      return [];
    }

    for (let i = 0; i < balance; i++) {
      tokens[i] = (await viem.readContract({
        abi,
        address: nftAddress,
        functionName: "tokenOfOwnerByIndex",
        args: [owner, i],
      })) as bigint;
    }

    return tokens;
  } catch (error) {
    console.log(error);
    return [];
  }
};

export const getBalanceOf = async (owner: Address, nftAddress: Address) => {
  const balance = await viem.readContract({
    abi,
    address: nftAddress,
    functionName: "balanceOf",
    args: [owner],
  });

  // console.log("balance: ", balance);
  return balance;
};

export const isApprovedForAll = async (
  owner: Address,
  mineAddress: Address,
) => {
  const result = await viem.readContract({
    abi,
    address,
    functionName: "isApprovedForAll",
    args: [owner, mineAddress],
  });

  return result;
};

export const totalSupply = async (nftAddress: Address) => {
  const result = await viem.readContract({
    abi,
    address: nftAddress,
    functionName: "totalSupply",
  });

  return result;
};

export const getCollectionOf = async (owner: Address) => {
  try {
    const collections = await getCollections();
    const data = await Promise.all(
      collections.map(async (col) => {
        const balance = (await getBalanceOf(owner, col.address)) as bigint;
        const supply = await totalSupply(col.address);
        if (balance > 0) {
          const tokens = await getTokensOfOwner(owner, col.address);
          const metadata = await getTokenURI(tokens, col.address);

          return {
            collection: col.collectionName,
            btn: col.button,
            slug: col.slug,
            balance,
            totalSupply: supply,
            metadata: metadata!,
          };
        }

        return {
          collection: col.collectionName,
          btn: col.button,
          slug: col.slug,
          balance,
          totalSupply: supply,
          metadata: [],
        };
      }),
    );

    return data;
  } catch (error) {
    console.log(error);
  }
};



================================================
FILE: src/server/api/services/reward.service.ts
================================================
import { Address, formatEther } from "viem";
import { viem } from "./viem.service";
import { address, abi } from "~/blockchain/ERC20/abi";

export const getBalanceOf = async (owner: Address) => {
  const balance = (await viem.readContract({
    address,
    abi,
    functionName: "balanceOf",
    args: [owner],
  })) as bigint;

  return (+formatEther(balance)).toFixed(10);
};



================================================
FILE: src/server/api/services/via-btc.service.ts
================================================
import puppeteer from "puppeteer";
import * as cheerio from "cheerio";

async function scarpe(pageContent: string) {
  const $ = cheerio.load(pageContent);

  const hashRateInfoPanel = $(".title span")
    .map((index, element) => {
      const title = $(element).text();
      const data = $(element)
        .parentsUntil(".info-panel")
        .next()
        .find(".f-num")
        .text();

      return {
        title,
        data,
      };
    })
    .get();

  return hashRateInfoPanel.length <= 0
    ? []
    : [hashRateInfoPanel[0], hashRateInfoPanel[1], hashRateInfoPanel[2]];
}

export async function scrapeViaBTC() {
  // Launch headless browser
  const browser = await puppeteer.launch();
  const page = await browser.newPage();

  // Navigate to the URL
  // "https://www.viabtc.com/observer/dashboard?access_key=4cf10e0b877a76547a3901c63d0ae89b&coin=LTC&type=active";
  await page.goto(process.env.VIA_BTC_URL!, { waitUntil: "networkidle0" });

  // Get the page content
  const pageContent = await page.content();

  const data = await scarpe(pageContent);

  // Close the browser
  await browser.close();
  return data;
}



================================================
FILE: src/server/api/services/viem.service.ts
================================================
import { Hex, createPublicClient, createWalletClient, http } from "viem";
import { privateKeyToAccount } from "viem/accounts";
import { bitkub, bitkub_testnet } from "~/blockchain/constants/bitkub";
import { jbc } from "~/blockchain/constants/jbc";

const key = process.env.digops as Hex;
let account;

if (key) {
  account = privateKeyToAccount(key);
}

export const viemJBCOps = createWalletClient({
  account,
  chain: jbc,
  transport: http(),
});

export const viem = createPublicClient({
  // chain: bitkub_testnet,
  chain: bitkub,
  transport: http(),
});

export const viemJBC = createPublicClient({
  chain: jbc,
  transport: http(),
});



================================================
FILE: src/server/api/services/v2/mine-v2.service.ts
================================================
import { groq } from "next-sanity";
import { client } from "../../../../../sanity/lib/client";
import { viem } from "../viem.service";
import { abi, address } from "~/blockchain/Mine/abi";
import {
  abi as abi2,
  address4,
  address5,
  address6,
  address7,
  address8,
} from "~/blockchain/Mine/abi2";
import {
  address1,
  address2,
  address3,
  address9,
  address10,
  address11,
  address12,
  address13,
  address14,
  address15,
  address16,
  address17,
  abi as abi3,
} from "~/blockchain/Mine/abi3";
import { MineType } from "sanity/schema/Mine";
import { Address, formatEther, formatUnits } from "viem";
import { contractAPRCalculator } from "../../utils/contractAPR";
import { getTokenURI } from "../nft.service";
import { calculateRewardTimeParameters } from "../../utils/RewardCalculation";
import { getBalanceOf } from "../reward.service";
import { getJibJibBalance } from "./jbc/jbc.distributor.service";
import { address as jibDistributor } from "~/blockchain/JBC/Distributor/abi";

const mines = [
  {
    mineName: "OG/JAN-2025",
    rewardToken: "KUB",
    image: "/images/dig-mine.jpg",
    abi: abi3,
    address: address1,
    link: "wallet",
  },
  {
    mineName: "OG/FEB-2025",
    rewardToken: "KUB",
    image: "/images/dig-mine.jpg",
    abi: abi2,
    address: address2,
    link: "wallet",
  },
  {
    mineName: "OG/APR",
    rewardToken: "kBTC",
    image: "/images/dig-mine.jpg",
    abi: abi2,
    address: address4,
    link: "wallet",
  },
  {
    mineName: "OG/MAY",
    rewardToken: "kBTC",
    image: "/images/dig-mine.jpg",
    abi: abi2,
    address: address5,
    link: "wallet",
  },
  {
    mineName: "OG/JUN",
    rewardToken: "kBTC",
    image: "/images/dig-mine.jpg",
    abi: abi2,
    address: address6,
    link: "wallet",
  },
  {
    mineName: "OG/JUL",
    rewardToken: "kBTC",
    image: "/images/dig-mine.jpg",
    abi: abi2,
    address: address7,
    link: "wallet",
  },
  {
    mineName: "OG/AUG",
    rewardToken: "kBTC",
    image: "/images/dig-mine.jpg",
    abi: abi2,
    address: address8,
    link: "wallet",
  },
  {
    mineName: "OG/SEP",
    rewardToken: "KUB",
    image: "/images/dig-mine.jpg",
    abi: abi3,
    address: address9,
    link: "wallet",
  },
  {
    mineName: "OG/OCT",
    rewardToken: "KUB",
    image: "/images/dig-mine.jpg",
    abi: abi3,
    address: address10,
    link: "wallet",
  },
  {
    mineName: "OG/NOV",
    rewardToken: "KUB",
    image: "/images/dig-mine.jpg",
    abi: abi3,
    address: address11,
    link: "wallet",
  },
  {
    mineName: "OG/DEC",
    rewardToken: "KUB",
    image: "/images/dig-mine.jpg",
    abi: abi3,
    address: address12,
    link: "wallet",
  },
  {
    mineName: "OG/MAR-2025",
    rewardToken: "KUB",
    image: "/images/dig-mine.jpg",
    abi: abi3,
    address: address3,
    link: "wallet",
  },
  {
    mineName: "OG/APR-2025",
    rewardToken: "KUB",
    image: "/images/dig-mine.jpg",
    abi: abi3,
    address: address13,
    link: "wallet",
  },
  {
    mineName: "OG/MAY-2025",
    rewardToken: "KUB",
    image: "/images/dig-mine.jpg",
    abi: abi3,
    address: address14,
    link: "wallet",
  },
  {
    mineName: "OG/JUN-2025",
    rewardToken: "KUB",
    image: "/images/dig-mine.jpg",
    abi: abi3,
    address: address15,
    link: "wallet",
  },
  {
    mineName: "OG/JUL-2025",
    rewardToken: "KUB",
    image: "/images/dig-mine.jpg",
    abi: abi3,
    address: address16,
    link: "wallet",
  },
  {
    mineName: "OG/AUG-2025",
    rewardToken: "KUB",
    image: "/images/dig-mine.jpg",
    abi: abi3,
    address: address17,
    link: "wallet",
  },
];

export const getMineData = async () => {
  try {
    const query = groq`*[_type == "minedata"]`;
    const data = await client.fetch(query);
    return data;
  } catch (error) {
    // console.log(error);
    return [];
  }
};

export const getActiveMineData = async () => {
  try {
    const query = groq`*[_type == "minedata" && isActive == true]`;
    const data = await client.fetch<typeof MineType>(query);
    return data;
  } catch (error) {
    // console.log(error);
    return [];
  }
};

export const getUserInfo = async (wallet: Address, mineeAddress: Address) => {
  try {
    const userInfo = (await viem.readContract({
      abi,
      //@ts-ignore
      address: mineeAddress,
      // address: mine[0].mineAddress,
      functionName: "getUserInfo",
      args: [wallet],
    })) as {
      stakedTokenIds: bigint[];
      stakedHashPowerAmount: bigint;
      lastIn: bigint;
      lastOut: bigint;
    };
    //@ts-ignore
    // const pendingReward = await getPendingReward(wallet, mine[0].mineAddress);
    const pendingReward = await getPendingReward(wallet, mineeAddress);

    // console.log({
    //   userInfo: {
    //     //@ts-ignore
    //     stakedTokenIds: userInfo.stakedTokenIds,
    //     //@ts-ignore
    //     stakedHashPowerAmount: userInfo.stakedHashPowerAmount,
    //     lastIn: userInfo.lastIn,
    //     lastOut: userInfo.lastOut,
    //   },
    //   // pendingReward,
    //   pendingReward: formatUnits(pendingReward[0] as bigint, 18),
    // });
    return {
      userInfo: {
        //@ts-ignore
        stakedTokenIds: userInfo.stakedTokenIds,
        //@ts-ignore
        stakedHashPowerAmount: userInfo.stakedHashPowerAmount,
        lastIn: userInfo.lastIn.toString(),
        lastOut: userInfo.lastOut.toString(),
      },
      // pendingReward,
      pendingReward: formatUnits(pendingReward[0] as bigint, 18),
    };
  } catch (error) {
    console.log(error);
    return undefined;
  }
};

export const getPendingReward = async (wallet: Address, mine: Address) => {
  try {
    const pendingReward = (await viem.readContract({
      address: mine,
      abi: abi2,
      functionName: "pendingReward",
      args: [wallet],
    })) as bigint;

    return [pendingReward];

    // if (mine == mines[0]?.address) {
    //   const pendingReward = (await viem.readContract({
    //     address: address,
    //     abi: abi,
    //     functionName: "pendingReward",
    //     args: [wallet],
    //   })) as [string, bigint];

    //   return [pendingReward[1]];
    // }

    // if (mine == mines[1]?.address) {
    //   const pendingReward = await viem.readContract({
    //     address: address2,
    //     abi: abi2,
    //     functionName: "pendingReward",
    //     args: [wallet],
    //   });

    //   return [pendingReward];
    // }

    // return [0];
  } catch (error) {
    // console.log(error);
    return [];
  }
};

export const getAllMineInfo = async (owner: Address) => {
  const data = await Promise.all(
    mines.map(async (mine) => {
      const mineInfo = await getMineInfo(mine.abi, mine.address as Address);
      const userInfo = await getPendingReward(owner, mine.address as Address);

      let balance = "";
      balance = mineInfo?.balance!;
      //IF KUB CONTRACT DO THIS
      if (mine.rewardToken == "KUB") {
        let b = await getKubBalance(mine.address as `0x${string}`);
        balance = formatEther(b);
      }

      // if (mine.address === address3) {
      //   balance = (await getJibJibBalance(jibDistributor)).toString();
      // }

      return {
        ...mineInfo,
        balance,
        name: mine.mineName,
        link: mine.link,
        rewardToken: mine.rewardToken,
        image: mine.image,
        pendingReward: formatUnits(userInfo[0] as bigint, 18) ?? 0,
      };
    }),
  );

  //SORTING
  const activeMines = data
    .filter((mine) => mine.isActive === true)
    .sort((a, b) => +b.startBlock.toString() - +a.startBlock.toString());
  const closedMines = data
    .filter((mine) => mine.isActive === false)
    .sort((a, b) => +b.startBlock.toString() - +a.startBlock.toString());

  return [...activeMines, ...closedMines];
};

export const getMineInfo = async (abi: any, address: Address) => {
  try {
    const info = (await viem.readContract({
      address: address,
      abi: abi as string[],
      functionName: "getMineInfo",
    })) as any;

    const currentBlock = await viem.getBlockNumber();
    const balance = await getBalanceOf(address);
    const totalStaked = await getTotalStakedTokens(address);
    const totalHash = await getTotalHashPower(address);

    const parsedData = {
      mine: address,
      nft: info.digdragon ?? "0x00",
      reward: info.reward ?? "0x00",
      hashpower: info.hashStorage ?? "0x00",
      feeCollector: info.feeCollector ?? "0x00",
      fee: info.fee ?? "0x00",
      startBlock: info.startBlock ?? 0,
      endBlock: info.rewardEndBlock ?? 0,
      rewardPerBlock: info.rewardPerBlock ?? 0,
      accTokenPerShare: info.accTokenPerShare ?? 0,
      rewardsForWithdrawal: info.rewardsForWithdrawal ?? 0,
      // totolStaked: info.totalStakedTokens ?? 0,
      totolStaked: totalStaked ?? 0,
      // totalHashPower: info.totalHashPower ?? 0,
      totalHashPower: totalHash ?? 0,
      isActive: info.rewardEndBlock > currentBlock,
      // info.rewardEndBlock > currentBlock && info.startBlock < currentBlock,
    };

    const apr =
      contractAPRCalculator(
        parsedData.rewardPerBlock,
        parsedData.totalHashPower,
        parsedData.accTokenPerShare,
      ) ?? 0;

    const { startTime, endTime } = await calculateRewardTimeParameters(
      parsedData.startBlock,
      parsedData.endBlock,
    );

    return { ...parsedData, apr, startTime, endTime, balance };
  } catch (error) {
    console.log(error);
    return null;
  }
};

export const getStakedTokenMetadataOf = async (
  wallet: string,
  nftAddress: string,
  mineAddress: Address,
) => {
  try {
    const user = await getUserInfo(wallet as Address, mineAddress);

    if (!user) {
      console.log("user not found");
      return [];
    }

    const stakedTokenIds = user.userInfo.stakedTokenIds as bigint[];
    const tokenUris = await getTokenURI(stakedTokenIds, nftAddress as Address);

    if (!tokenUris) {
      return [];
    }

    const stakedUris = tokenUris.map((uri) => ({ ...uri, staked: true }));

    return stakedUris;
  } catch (error: any) {
    console.log("getStakedTokenMetadataOf", error.message);
    return [];
  }
};

export const getTotalStakedTokens = async (address: Address) => {
  const totalStakedTokens = (await viem.readContract({
    address: address,
    abi,
    functionName: "totalStakedTokens",
  })) as any;
  return totalStakedTokens;
};

export const getTotalHashPower = async (address: Address) => {
  const hashPower = (await viem.readContract({
    address: address,
    abi,
    functionName: "totalHashPower",
  })) as any;

  return hashPower;
};

export const getKubBalance = async (mine: `0x${string}`) => {
  const balance = (await viem.readContract({
    address: mine,
    abi: abi3,
    functionName: "getBalance",
  })) as bigint;
  return balance;
};



================================================
FILE: src/server/api/services/v2/jbc/jbc.distributor-whitelist.service.ts
================================================
import { viemJBCOps, viemJBC, viem } from "../../viem.service";
import { abi as jbcAbi, jibjibAddress } from "~/blockchain/ERC20/abi";
import {
  abi as jbcDisAbi,
  address,
} from "~/blockchain/JBC/DistributorWhitelist/abi";
import { address as nftAddress } from "~/blockchain/NFT/abi";

import { Address, formatEther, parseEther, parseUnits } from "viem";
import { getTokensOfOwner } from "../../nft.service";

// import { client } from "../../../../../../sanity/lib/client";
// import { groq } from "next-sanity";

// export async function checkApproveable(wallet: string) {
//   const claimable = await isClaimable(wallet);
//   const tokens = await getTokensOfOwner(wallet as Address, nftAddress);
//   console.log("tokens ", tokens.toString());
//   console.log("claimable ", claimable);
//   const query = groq`*[_type == "jibjib" && wallet == "${wallet}"]{ wallet, tokenIds, approved}`;
//   const result = (await client.fetch(query)) as {
//     wallet: string;
//     tokenIds: string;
//     approved: boolean;
//   }[];
//   if (claimable) {
//     if (result.length <= 0) {
//       //has no data before
//       await client.create({
//         _type: "jibjib",
//         wallet,
//         tokenIds: tokens.toString(),
//         approved: true,
//       });
//       return true;
//     }

//     const found = result.find((w) => w.wallet == wallet);

//     if (!found) {
//       await client.create({
//         _type: "jibjib",
//         wallet,
//         tokenIds: tokens.toString(),
//         approved: true,
//       });
//       return true;
//     }

//     if (found.approved) {
//       return false;
//     }
//   } else {
//     if (result.length <= 0) {
//       await client.create({
//         _type: "jibjib",
//         wallet,
//         tokenIds: tokens.toString(),
//         approved: true,
//       });
//       return false;
//     }

//     const found = result.find((w) => w.wallet == wallet);

//     if (!found) {
//       await client.create({
//         _type: "jibjib",
//         wallet,
//         tokenIds: tokens.toString(),
//         approved: true,
//       });
//       return false;
//     }

//     if (found.approved) {
//       return false;
//     }
//   }
// }

export async function getJibJibBalance(owner: string) {
  const balance = (await viemJBC.readContract({
    abi: jbcAbi,
    address: jibjibAddress,
    functionName: "balanceOf",
    args: [owner],
  })) as bigint;

  return (+formatEther(balance)).toFixed(10);
}

export async function getPreClaimable(owner: string) {
  const rewardPerToken = 250000;
  const tokenOfOwner = await getTokensOfOwner(owner as Address, nftAddress);

  const rewards = (tokenOfOwner.length * rewardPerToken).toString();
  const parsedReward = parseEther(rewards, "wei");
  return formatEther(parsedReward, "wei");
}

export async function updateReward(owner: string) {
  // const rewardPerToken = 250000;
  const tokenOfOwner = await getTokensOfOwner(owner as Address, nftAddress);

  // const rewards = (tokenOfOwner.length * rewardPerToken).toString();
  // const parsedReward = parseEther(rewards, "wei");
  const approvable = await isApprovable(tokenOfOwner);

  if (approvable) {
    await viemJBCOps.writeContract({
      abi: jbcDisAbi,
      address: address,
      functionName: "updateReward",
      // args: [owner, parsedReward, tokenOfOwner],
      args: [owner, tokenOfOwner],
      gasPrice: parseEther("5", "gwei"),
    });

    return true;
  } else {
    return false;
  }
}

export async function getClaimableOf(owner: string) {
  const claimable = (await viemJBC.readContract({
    abi: jbcDisAbi,
    address: address,
    functionName: "getClaimableOf",
    args: [owner],
  })) as bigint;

  return (+formatEther(claimable)).toFixed(10) ?? 0;
}

export async function isApprovable(tokens: bigint[]) {
  const approvable = await viemJBC.readContract({
    abi: jbcDisAbi,
    address: address,
    functionName: "isApprovable",
    // args: [owner, parsedReward, tokenOfOwner],
    args: [tokens],
  });
  return approvable;
}

export async function checkApproveable(owner: string) {
  const tokenOfOwner = await getTokensOfOwner(owner as Address, nftAddress);
  const approvable = await isApprovable(tokenOfOwner);
  return approvable;
}

// export async function isClaimable(owner: string) {
//   const canClaim = await viemJBC.readContract({
//     abi: jbcDisAbi,
//     address: address,
//     functionName: "isClaimable",
//     args: [owner],
//   });

//   return canClaim;
// }



================================================
FILE: src/server/api/services/v2/jbc/jbc.distributor.service.ts
================================================
import { viemJBCOps, viemJBC } from "../../viem.service";
import { abi as jbcAbi, jibjibAddress } from "~/blockchain/ERC20/abi";
import { abi as jbcDisAbi, address } from "~/blockchain/JBC/Distributor/abi";

import { formatEther } from "viem";

export async function getJibJibBalance(owner: string) {
  const balance = (await viemJBC.readContract({
    abi: jbcAbi,
    address: jibjibAddress,
    functionName: "balanceOf",
    args: [owner],
  })) as bigint;

  return (+formatEther(balance)).toFixed(10);
}

export async function updateReward(owner: string, pendingReward: bigint) {
  const result = await viemJBCOps.writeContract({
    abi: jbcDisAbi,
    address: address,
    functionName: "updateReward",
    args: [owner, pendingReward],
  });

  return result;
}

export async function getClaimableOf(owner: string) {
  const claimable = (await viemJBC.readContract({
    abi: jbcDisAbi,
    address: address,
    functionName: "getClaimableOf",
    args: [owner],
  })) as bigint;

  return (+formatEther(claimable)).toFixed(10);
}

export async function isClaimable(owner: string) {
  const canClaim = await viemJBC.readContract({
    abi: jbcDisAbi,
    address: address,
    functionName: "isClaimable",
    args: [owner],
  });

  return canClaim;
}



================================================
FILE: src/server/api/utils/contractAPR.ts
================================================
export function contractAPRCalculator(
  rewardPerBlock: bigint,
  totalHashPower: bigint,
  accTokenPerShare: bigint,
) {
  if (!rewardPerBlock || !totalHashPower || !accTokenPerShare) return 0;
  const blockPerYear = 6307200;
  const rewardPerYear = parseFloat(rewardPerBlock.toString()) * blockPerYear;
  const totalValue =
    (parseFloat(totalHashPower.toString()) *
      parseFloat(accTokenPerShare.toString())) /
    1e12;
  const APR = (rewardPerYear / totalValue) * 100;
  return APR;
}



================================================
FILE: src/server/api/utils/RewardCalculation.ts
================================================
import dayjs from "dayjs";
import { viem } from "../services/viem.service";

const blockTime = 5; //Bitkub blocktime
const dayInSecs = 86400;
const dayBlocks = dayInSecs / blockTime;
const monthBlocks = dayBlocks * 30;
const yearBlocks = monthBlocks * 12;

async function calculateTimeFromBlock(block: bigint) {
  const currentBlock = await viem.getBlockNumber();
  const currentBlockTime = dayjs(new Date());
  const blockDiff = block - currentBlock;
  const totalBlocksTimeInHour =
    parseInt(blockDiff.toString()) / (3600 / blockTime);
  const estimateBlockTimestamp = currentBlockTime
    .add(totalBlocksTimeInHour, "h")
    .format("YYYY-MM-DD | HH:mm");
  return estimateBlockTimestamp;
}

export async function calculateRewardTimeParameters(
  startBlock: bigint,
  endBlock: bigint,
) {
  const startTime = await calculateTimeFromBlock(startBlock);
  const endTime = await calculateTimeFromBlock(endBlock);

  return { startTime, endTime };
}



================================================
FILE: src/styles/globals.css
================================================
@tailwind base;
@tailwind components;
@tailwind utilities;



@layer base {
    h1 { @apply text-2xl; }
    h2 { @apply text-xl; }
}


================================================
FILE: src/types/Address.ts
================================================
export type Address = `0x${string}`;



================================================
FILE: src/utils/api.ts
================================================
/**
 * This is the client-side entrypoint for your tRPC API. It is used to create the `api` object which
 * contains the Next.js App-wrapper, as well as your type-safe React Query hooks.
 *
 * We also create a few inference helpers for input and output types.
 */
import { httpBatchLink, loggerLink } from "@trpc/client";
import { createTRPCNext } from "@trpc/next";
import { type inferRouterInputs, type inferRouterOutputs } from "@trpc/server";
import superjson from "superjson";

import { type AppRouter } from "~/server/api/root";

const getBaseUrl = () => {
  if (typeof window !== "undefined") return ""; // browser should use relative url
  if (process.env.VERCEL_URL) return `https://${process.env.VERCEL_URL}`; // SSR should use vercel url
  return `http://localhost:${process.env.PORT ?? 3000}`; // dev SSR should use localhost
};

/** A set of type-safe react-query hooks for your tRPC API. */
export const api = createTRPCNext<AppRouter>({
  config() {
    return {
      /**
       * Transformer used for data de-serialization from the server.
       *
       * @see https://trpc.io/docs/data-transformers
       */
      transformer: superjson,

      /**
       * Links used to determine request flow from client to server.
       *
       * @see https://trpc.io/docs/links
       */
      links: [
        loggerLink({
          enabled: (opts) =>
            process.env.NODE_ENV === "development" ||
            (opts.direction === "down" && opts.result instanceof Error),
        }),
        httpBatchLink({
          url: `${getBaseUrl()}/api/trpc`,
        }),
      ],
    };
  },
  /**
   * Whether tRPC should await queries when server rendering pages.
   *
   * @see https://trpc.io/docs/nextjs#ssr-boolean-default-false
   */
  ssr: false,
});

/**
 * Inference helper for inputs.
 *
 * @example type HelloInput = RouterInputs['example']['hello']
 */
export type RouterInputs = inferRouterInputs<AppRouter>;

/**
 * Inference helper for outputs.
 *
 * @example type HelloOutput = RouterOutputs['example']['hello']
 */
export type RouterOutputs = inferRouterOutputs<AppRouter>;


